#if TARGET_OS_SIMULATOR
#if 0
#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.0.1 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreMotion;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeoUniq",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, ConsentItem, closed) {
  ConsentItemCustomization = 0,
  ConsentItemAnalisys = 1,
};


SWIFT_CLASS("_TtC7GeoUniq11ConsentsMap")
@interface ConsentsMap : NSObject
- (BOOL)containsValueWithValue:(BOOL)value SWIFT_WARN_UNUSED_RESULT;
- (BOOL)getWithKey:(enum ConsentItem)key SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Object which describe the configuration of the http request when forwarding locations
SWIFT_CLASS("_TtC7GeoUniq14CustomEndpoint")
@interface CustomEndpoint : NSObject
/// url for the request
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// dictionary representing the headers of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable headers;
/// dictionary representing the query string parameters of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable queryStringParameters;
/// object which will be delivered together with the locations
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable customData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class delegate to the build of <code>CustomEndpoint</code> Objects.
/// First create a CustomEndpointBuilder instance: <code>CustomEndpointBuilder()</code>, then add every parameter you need: url, headers, query string parameters and custom data
/// The custom data is an object which will be delivered with the location
/// Example: let customEndPoint = CustomEndpointBuilder().setUrl(‘http://dodo.com’).setHeader(key: ‘token’, value: ‘Bearer empty’).build()
/// Remember: if you set an http url insted of an https you have to enable it into the Info.plist file.
SWIFT_CLASS("_TtC7GeoUniq21CustomEndpointBuilder")
@interface CustomEndpointBuilder : NSObject
/// Instantiate the builder
///
/// returns:
/// the object created
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Instantiate the builder with the given CustomEndpoint
/// \param customEndpoint existing customEndpoint
///
///
/// returns:
/// the object created
- (nonnull instancetype)initWithCustomEndpoint:(CustomEndpoint * _Nonnull)customEndpoint OBJC_DESIGNATED_INITIALIZER;
/// Set the url for the <code>CustomEndpoint</code> object
/// \param url http/s url
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidUrlException
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setUrlWithUrl:(NSString * _Nonnull)url error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set a single header value
/// \param key key of the header
///
/// \param value value of the header
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeaderWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Remove an heder value given the key
/// \param key the key to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeHeaderWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set all the header to be used in the <code>CustomEndpoint</code>. All the previously set header parameter will be replaced
/// \param headers dictionary of the headers
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeadersWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers SWIFT_WARN_UNUSED_RESULT;
/// Remove all the headers set
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllHeaders SWIFT_WARN_UNUSED_RESULT;
/// Add a query string parameter
/// \param key key of the parameter
///
/// \param value value of the parameter
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParameterWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Set the query string parameters, all the previously set will be replaced
/// \param parameters parameters dicionary
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParametersWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters SWIFT_WARN_UNUSED_RESULT;
/// Remove a single query string parameter
/// \param key key of the parameter to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeQueryStringParameterWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Remove all the query string parameters
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllQueryStringParameters SWIFT_WARN_UNUSED_RESULT;
/// Set the custom date. This object will be sent together with the location object.
/// It has to be a valid JSON serializable object, an error will be thrown otherwise.
/// Serializability is check with the method: <code>JSONSerialization.isValidJSONObject(data)</code>
/// \param data custom object
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidJSONObject
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setCustomDataWithData:(NSDictionary<NSString *, id> * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Remove the previously set custom data, if any
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeCustomData SWIFT_WARN_UNUSED_RESULT;
/// Enable or disable the forwarding locations with the custom enpoint
/// \param enabled boolean
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setEnabledWithEnabled:(BOOL)enabled SWIFT_WARN_UNUSED_RESULT;
/// Build and return the <code>CustomEndpoint</code> built with the set parameters
///
/// throws:
/// CustomEndpoint.NoUrlDefinedException
///
/// returns:
/// the <code>CustomEndpoint</code> object correctly built
- (CustomEndpoint * _Nullable)buildAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// Exceptions defining errors during the build of the CustomEndpoint with the Builder
typedef SWIFT_ENUM(NSInteger, CustomEndpointException, closed) {
/// Invalid url exception
  CustomEndpointExceptionInvalidUrlException = 0,
/// No url defined
  CustomEndpointExceptionNoUrlDefinedException = 1,
/// Invalid Json Object
  CustomEndpointExceptionInvalidJSONObject = 2,
};
static NSString * _Nonnull const CustomEndpointExceptionDomain = @"GeoUniq.CustomEndpointException";

@class GUMotionActivity;

/// Delegate to implement in order to receive the callback for the change of activity event
SWIFT_PROTOCOL("_TtP7GeoUniq18GUActivityDelegate_")
@protocol GUActivityDelegate
/// Public constructor
- (nonnull instancetype)init;
/// Called on activity change
/// \param started new activity that triggered the event
///
/// \param finished previous activity
///
- (void)onActivityChangedWithStarted:(GUMotionActivity * _Nonnull)started finished:(GUMotionActivity * _Nonnull)finished;
@end

@class GUGeoPoint;

/// Represents a circular area.
SWIFT_CLASS("_TtC7GeoUniq14GUCircularArea")
@interface GUCircularArea : NSObject <NSCopying>
/// The center of the circle
@property (nonatomic, strong) GUGeoPoint * _Nonnull center;
/// The radius of the circle
@property (nonatomic) double radius;
/// The name of the area
@property (nonatomic, copy) NSString * _Nullable name;
/// The description of the area
@property (nonatomic, copy) NSString * _Nullable areaDescription;
/// Public constructor
/// \param center The center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithCenter:(GUGeoPoint * _Nonnull)center radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
/// Public constructor
/// \param latitude latitude of the center of the circle
///
/// \param longitude longitude of the center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Enumeration describing generic error
typedef SWIFT_ENUM(NSInteger, GUError, closed) {
/// The permission of the localization service has been denied, no location will be delivered
  GUErrorDeniedLocalizationPermission = 0,
/// The permission of the localization service has not yet been granted, the locations will arrive when the permission will be granted.
  GUErrorNotDeterminedLocalizationPermission = 1,
/// A general/unknown error occurred
  GUErrorGeneralError = 2,
/// The Location updates has not been request in <code>background modes</code> section
  GUErrorBackgroundLocationUpdates = 3,
};


/// Represents a geographical point through the latitide and longitude coordinates.
SWIFT_CLASS("_TtC7GeoUniq10GUGeoPoint")
@interface GUGeoPoint : NSObject
/// latitude of the point
@property (nonatomic) double latitude;
/// longitude of the point
@property (nonatomic) double longitude;
/// Public constructor
/// \param latitude latitude of the point
///
/// \param longitude longitude of the point
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface GUGeoPoint (SWIFT_EXTENSION(GeoUniq)) <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end



enum Status : NSInteger;

/// Represents a geographical area that is monitored with the associated callback class. These objects are returned when calling the func <code>setGUGeofence()</code>, <code>getAllGUGeofence()</code>
SWIFT_CLASS("_TtC7GeoUniq10GUGeofence")
@interface GUGeofence : NSObject
/// A unique id for the <code>GUGeofence</code> Object. It can be used to remove a Geofence through the func <code>removeGUGeonfece()</code>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The area that is being monitored
@property (nonatomic, readonly, strong) GUCircularArea * _Nonnull area;
/// The name of the class that will receive callbacks when the device enters and exits the monitored area, according to the <code>GUGeofenceListener</code> protocol
@property (nonatomic, readonly, copy) NSString * _Nonnull callBackClass;
/// <code>GUGeofence.Status</code> of the geofence when the Object is obtained
@property (nonatomic, readonly) enum Status status;
/// Expiration date of the geofence, after this date the geofence will be deleted
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// Date of last status change
@property (nonatomic, readonly, copy) NSDate * _Nullable lastStatusChange;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, Status, closed) {
/// UNKNOWN
///
/// returns:
/// Inidcates that it was not possible to determine whether the device is iside or outside the monitored area. This Status is possible only when the position of the device has never been obtained.
  StatusUNKNOWN = 0,
/// INSIDE
///
/// returns:
/// indicates that the device is inside the monitored area
  StatusINSIDE = 1,
/// OUTSIDE
///
/// returns:
/// indicates that the device is outside the monitored area
  StatusOUTSIDE = 2,
};




/// Defines the callback functions called when a device enters or exits a <code>GUGeofence</code>.
/// This protocol has to be adopted by the class associated to a <code>GUGeofence</code> object <code>setGUGeofence()</code>
SWIFT_PROTOCOL("_TtP7GeoUniq18GUGeofenceListener_")
@protocol GUGeofenceListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when the device enters the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didEnterGUGeofence:(GUGeofence * _Nonnull)geofence;
/// Called when the device exits the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didExitGUGeofence:(GUGeofence * _Nonnull)geofence;
@end

@class NSNumber;

/// Object which wrap the location resulting in: latitude, longitude, time and motion activity
SWIFT_CLASS("_TtC7GeoUniq10GULocation")
@interface GULocation : NSObject
/// latitude of the location
@property (nonatomic) double latitude;
/// longitude of the location
@property (nonatomic) double longitude;
/// time of the location
@property (nonatomic, copy) NSDate * _Nonnull time;
/// motionActivity of the location
@property (nonatomic, copy) NSString * _Nonnull motionActivity;
/// visit duration of the location in seconds
@property (nonatomic) double visitDuration;
/// accuracy
@property (nonatomic, strong) NSNumber * _Nullable accuracy;
/// Public constructor
/// \param latitude latitude of the location
///
/// \param longitude logitude of the location
///
/// \param time time of the location
///
/// \param motionActivity motionActivity of the location
///
/// \param accuracy accuracy of the location
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude time:(NSDate * _Nonnull)time motionActivity:(NSString * _Nonnull)motionActivity confirmedAt:(NSDate * _Nonnull)confirmedAt accuracy:(NSNumber * _Nullable)accuracy OBJC_DESIGNATED_INITIALIZER;
/// Obtain a representation of the location in the form:
/// “latitude”: Double
/// “longitude”: Double
/// “time”: NSDate
/// “motionActivity”: String
/// “accuracy”: NSNumber
- (NSDictionary<NSString *, id> * _Nonnull)getGULocation SWIFT_WARN_UNUSED_RESULT;
/// Return the description in a json serialization form
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Protocol to implement in order to receive callbakcs about location history
SWIFT_PROTOCOL("_TtP7GeoUniq25GULocationHistoryReceiver_")
@protocol GULocationHistoryReceiver
/// Callback method called to return the list of positions retrieved form GeoUniq Analytics cloud platform
/// \param locations list of Locations object
///
- (void)onSuccess:(NSArray<GULocation *> * _Nonnull)locations;
/// Callback method called when an error occurs during the communication with GeoUniq Analytics cloud platform.
- (void)onError;
@end

enum GUMotionType : NSInteger;

/// Models a motion activity, that is, a period of time during which the same motion type (see <code>GUMotionType</code>) has been observed
SWIFT_CLASS("_TtC7GeoUniq16GUMotionActivity")
@interface GUMotionActivity : NSObject
/// Allows to obtain the <code>GUMotionType</code> of movement of this GUMotionActivity
@property (nonatomic, readonly) enum GUMotionType type;
/// Allows to obtain the start time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
/// Allows to obtain the end time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nullable endTime;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Enumeration that describe the activity of the user
typedef SWIFT_ENUM(NSInteger, GUMotionType, closed) {
/// Not Moving
///
/// returns:
/// not moving activity
  GUMotionTypeStill = 0,
/// Walking
///
/// returns:
/// walking activity
  GUMotionTypeWalking = 1,
/// Running
///
/// returns:
/// running activity
  GUMotionTypeRunning = 2,
/// cycling
///
/// returns:
/// cycling activity
  GUMotionTypeCycling = 3,
/// Automotive
///
/// returns:
/// automotive activity
  GUMotionTypeAutomotive = 4,
/// Unknown
///
/// returns:
/// unknown activity
  GUMotionTypeUnknown = 5,
};

@class CLLocation;
@class NSError;

/// Delegate to implement in order to receive the locations when the app is suspended
SWIFT_PROTOCOL("_TtP7GeoUniq18GUOfflineStreaming_")
@protocol GUOfflineStreaming
/// Public constructor
- (nonnull instancetype)init;
/// Called on new location detected
/// \param location new location detected
///
- (void)newLocationReceived:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUPositionReceiver_")
@protocol GUPositionReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive the locations in streaming
SWIFT_PROTOCOL("_TtP7GeoUniq17GUOnlineStreaming_")
@protocol GUOnlineStreaming <GUPositionReceiver>
/// Return a value identifying the Object. This is use to avoid replication when registering for a streaming
///
/// returns:
/// <#return value description#>
- (NSString * _Nonnull)getIdentifier SWIFT_WARN_UNUSED_RESULT;
@end



/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GURealTimeReceiver_")
@protocol GURealTimeReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(enum GUError)guError error:(NSError * _Nullable)error;
@end

/// Enumeration which provide you the different values of sort
/// <ul>
///   <li>
///     timestampAsc: Sort by ascending timestamp
///   </li>
///   <li>
///     timestampDes: Sort by descending timestamp
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GUSort, closed) {
/// Sort by ascending time
  GUSortTimeAsc = 0,
/// Sort by descending time
  GUSortTimeDesc = 1,
};


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUTrackingListener_")
@protocol GUTrackingListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onNewLocationUpdate:(GULocation * _Nonnull)location;
@end


/// GeoUniq class. Every method can be accessed by the sharedInstance() method. The very first time call the method setMobileKey(mobileKey: String) to authenticate the device and start the tracking.
SWIFT_CLASS("_TtC7GeoUniq7GeoUniq")
@interface GeoUniq : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_CUSTOM_ID_LENGTH;)
+ (NSInteger)MAX_CUSTOM_ID_LENGTH SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Obtain the version name of GeoUniq framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull FrameworkVersionName;)
+ (NSString * _Nonnull)FrameworkVersionName SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq. You will also notify about the device-id
/// \param callbackDeviceId function callback where you will be notify about the device-id
///
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance:(void (^ _Nonnull)(NSString * _Nonnull))callbackDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Return the mobileKeykey in the info.plist file or nil if none
///
/// returns:
/// the mobileKey provided
- (NSString * _Nullable)getMobileKey SWIFT_WARN_UNUSED_RESULT;
/// Return the id relative to the device if it has been registered, nil otherwise.
/// You should handle the device id in the callback of the sharedInstance() method
///
/// returns:
/// the device id if available or nil otherwise
- (NSString * _Nullable)getDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Enable the tracking of the device.
/// If the tracking is running this method has no influence on the system.
- (void)enable;
/// Disable the tracking of the device (until the application is not killed)
/// It will restart when explicitly call start() method or sharedInstance(…) if the key GUAutoStartedTracking is set to true
- (void)disable;
/// Return the starting granularity if the basic tracking is set to true, nil otherwise
/// If the basic tracking is set to true but no accuracy has been provided, will be returned the default granularity (10000)
///
/// returns:
/// the starting granularity in meters
- (double)getStartingTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking
/// \param granularity set the starting granularity in meters
///
- (void)setStartingTrackingGranularity:(double)granularity;
/// Reset the value to the one provided in the Info.plist file
- (void)resetStartingTrackingGranularity;
/// Return the granularity of the current tracking session(until the app is killed)
///
/// returns:
/// granularity for the current tracking session
- (double)getCurrentTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking of this session (until the app is killed), then will be used the starting accuracy provided if the service is open
/// \param granularity the granularity in meters for the current tracking session
///
- (void)setCurrentTrackingGranularity:(double)granularity;
/// Ask GeoUniq for a location with the given accuracy.
/// \param accuracy accuracy requested for the position
///
/// \param callback class delegate to receive the location
///
- (void)getPosition:(double)accuracy callback:(id <GUPositionReceiver> _Nonnull)callback;
/// Allow the print of the log for warnings and errors
/// \param enable true if you want to print out the logs
///
- (void)enableDebug:(BOOL)enable;
/// Return true if the tracking is active
///
/// returns:
/// boolean
- (BOOL)isTrackingActive SWIFT_WARN_UNUSED_RESULT;
/// Call on the background fetch event of the device
- (void)backgroundFetch;
/// Register the application for the background fetch with the minimum interval (UIApplicationBackgroundFetchIntervalMinimum)
- (void)registerBackgroundFetch;
/// Register the device to receive remote notifications, if the iOS version is older than 8.0.0 register the device for Badge, Alert and Sounds. You Will receive the device token in the application:didRegisterForRemoteNotificationsWithDeviceToken method, or in application:didReceiveRemoteNotification in case of errors; remember to forward the deviceToken to GeoUniq service with the method ‘registerDeviceToken(deviceToken: NSData)’
- (void)registerRemoteNotifications;
/// Forward the device token received by the application:didRegisterForRemoteNotificationsWithDeviceToken method
/// \param deviceToken token provided by iOS
///
- (void)registerDeviceToken:(NSData * _Nonnull)deviceToken;
/// Set the label for the tracking session. The value will label all future positions on the server until you explicitelly change it or reset it.
/// The max String length is 10000 characters.
/// \param label label you want to assing to the tracking session
///
///
/// returns:
/// true if the string could used for the label
- (BOOL)setLabelSession:(NSString * _Nullable)label SWIFT_WARN_UNUSED_RESULT;
/// Get the label for the tracking session
///
/// returns:
/// the label for the tracking session
- (NSString * _Nullable)getLabelSession SWIFT_WARN_UNUSED_RESULT;
/// Reset the label to the default value (nil)
- (void)resetLabel;
/// Request motion activity permission for use the hardaware chip
- (void)requestMotionActivityPermission;
/// Get motion activity permission status (aviable only from iOS 11)
///
/// returns:
/// the current authorization status
- (CMAuthorizationStatus)getMotionActivityPermission SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=11.0);
/// Return the current motion activity (the last detected)
///
/// returns:
/// the current activity
- (GUMotionActivity * _Nullable)getCurrentActivity SWIFT_WARN_UNUSED_RESULT;
/// Get privacy consent status
- (BOOL)getConsentStatus SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "getPrivacyConsents");
/// set privacy consent status
- (void)setConsentStatusWithIsGranted:(BOOL)isGranted SWIFT_DEPRECATED_MSG("", "setPrivacyConsent");
/// show pop-up for privacy consent ask and set status
/// -returns: completion isGranted (Bool)
- (void)showConsentDialogAndSetWithCompletion:(void (^ _Nonnull)(BOOL))completion SWIFT_DEPRECATED_MSG("", "showPrivacyPolicyAndSetWithCompletion:");
- (void)showPrivacyPolicyAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)showPrivacyPolicySwitchesAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)setPrivacyConsent:(enum ConsentItem)consent value:(BOOL)value;
- (BOOL)getPrivacyConsent:(enum ConsentItem)consent SWIFT_WARN_UNUSED_RESULT;
- (ConsentsMap * _Nonnull)getPrivacyConsentsMap SWIFT_WARN_UNUSED_RESULT;
/// Obtain the last location registered
- (GULocation * _Nullable)getLastKnownLocation SWIFT_WARN_UNUSED_RESULT;
/// Obtain the location history of the device given a timeframe and a type of sort
/// \param from start time frame
///
/// \param to end of the time frame
///
/// \param sort type of sort for the locations
///
/// \param locationsReceiver callback on which the locations will be delivered
///
- (void)getLocationHistory:(NSDate * _Nonnull)from to:(NSDate * _Nonnull)to sort:(enum GUSort)sort locationsReceiver:(id <GULocationHistoryReceiver> _Nonnull)locationsReceiver;
/// Allows to register this Device to all the Groups whose name is equal to the parameter
/// \param name indicating the name of the Group(s) of interest
///
- (void)registerToGroupsWithName:(NSString * _Nonnull)name;
/// Allows to register this Device to the Group whose ID is equal to the parameter
/// \param groupId indicating the ID of the Group of interest
///
- (void)registerToGroupWithId:(NSString * _Nonnull)groupId;
/// Store the Cusom Endpoint Object to use for the Location forwarding.
/// In order to create the <code>CustomEndpoint</code> object use <code>CustomEndpoint.Builder</code>, it will allow you to build correctly the <code>CustomEndpoint</code>.
/// After this method remember to call <code>.enableCustomEndpoint()</code> in order to enable the forward of locations
/// \param endpoint representation of the parameters of the call
///
- (void)setCustomEndpointWithEndpoint:(CustomEndpoint * _Nonnull)endpoint;
/// Return the <code>CustomEndpoint</code> in use
///
/// returns:
/// custom endpoint
- (CustomEndpoint * _Nullable)getCustomEndpoint SWIFT_WARN_UNUSED_RESULT;
/// Remove the ´CustomEnpoint´ in use, this command will disable the forwards of locations
- (void)removeCustomEndpoint;
/// Enable the forward of locations using the parameters in the <code>CustomEnpoint</code> stored
- (void)enableCustomEndpoint;
/// Disable the forward of locations, the <code>CustomEndpoint</code> is still stored for a later use
- (void)disableCustomEndpoint;
/// Return the current state of the forwarding locations to a custom endpoint: enabled or disabled
///
/// returns:
/// boolean
- (BOOL)isCustomEndpointEnabled SWIFT_WARN_UNUSED_RESULT;
/// Check if the tracking is possible on this device, the parameters checked are:
/// <ul>
///   <li>
///     location permission granted or not determined
///   </li>
///   <li>
///     parameters in Info.plist file correctly provided
///   </li>
/// </ul>
/// In addition will be logged (if enabled) the status of permission
///
/// returns:
/// the possibility to track the device
- (BOOL)isLocationTrackingAvailable SWIFT_WARN_UNUSED_RESULT;
/// Register a delegate to receive all the locations update, even in background
/// \param listener listener to register
///
- (void)setTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener;
/// Remove a registered delegate for locations update
/// \param listener registered listener
///
///
/// returns:
/// true if a argument listener exists. False otherwise.
- (BOOL)removeTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener SWIFT_WARN_UNUSED_RESULT;
/// Allows to obtain the set listeners
///
/// returns:
/// <code>[GUTrackingListener.Type]</code>
- (NSArray<Class <GUTrackingListener>> * _Nullable)getTrackingListeners SWIFT_WARN_UNUSED_RESULT;
/// Removes all listener previously set
- (void)removeAllTrackingListeners;
- (BOOL)setCustomId:(NSString * _Nonnull)customId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCustomId SWIFT_WARN_UNUSED_RESULT;
/// Sets  a <code>GUGeofence</code> for the geographical area indicated by area argument
/// and the callback class indicated by the listener argument
/// \param area A <code>GUCircularArea</code> representing the circular area to be monitored
///
/// \param listener A class adopting the <code>GUGeofenceListener</code> protocol
///
/// \param expirationDate Expiration date of the <code>GUGeofence</code>, after this date the <code>GUGeofence</code> will be deleted
///
///
/// returns:
/// the created <code>GUGeofence</code> object
- (GUGeofence * _Nonnull)setGUGeofenceWithArea:(GUCircularArea * _Nonnull)area listener:(Class <GUGeofenceListener> _Nonnull)listener expirationDate:(NSDate * _Nullable)expirationDate SWIFT_WARN_UNUSED_RESULT;
/// Removes the <code>GUGeofence</code> with id equal to the <code>id</code> argument, if any.
/// \param id the id of the <code>GUGeofence</code> to be removed
///
///
/// returns:
/// true if a <code>GUGeofence</code> with the provided id exists. False otherwise.
- (BOOL)removeGUGeofenceWithId:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Removes all <code>GUGeofence</code> previously set
- (void)removeAllGUGeofence;
/// Allows to obtain the set <code>GUGeofence</code> objects
///
/// returns:
/// <code>[GUGeofence]</code>
- (NSArray<GUGeofence *> * _Nonnull)getGUGeofences SWIFT_WARN_UNUSED_RESULT;
- (NSArray<GUGeofence *> * _Nonnull)getRemoteGUGeofences SWIFT_WARN_UNUSED_RESULT;
@end


/// Responsible for handling all delegate callbacks for the underlying session.
SWIFT_CLASS("_TtC7GeoUniq15SessionDelegate")
@interface SessionDelegate : NSObject
/// Initializes the <code>SessionDelegate</code> instance.
///
/// returns:
/// The new <code>SessionDelegate</code> instance.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Returns a <code>Bool</code> indicating whether the <code>SessionDelegate</code> implements or inherits a method that can respond
/// to a specified message.
/// \param selector A selector that identifies a message.
///
///
/// returns:
/// <code>true</code> if the receiver implements or inherits a method that can respond to selector, otherwise <code>false</code>.
- (BOOL)respondsToSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
@end

@class NSURLSession;
@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDownloadDelegate>
/// Tells the delegate that a download task has finished downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that finished.
///
/// \param location A file URL for the temporary file. Because the file is temporary, you must either
/// open the file for reading or move it to a permanent location in your app’s sandbox
/// container directory before returning from this delegate method.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
/// Periodically informs the delegate about the download’s progress.
/// \param session The session containing the download task.
///
/// \param downloadTask The download task.
///
/// \param bytesWritten The number of bytes transferred since the last time this delegate
/// method was called.
///
/// \param totalBytesWritten The total number of bytes transferred so far.
///
/// \param totalBytesExpectedToWrite The expected length of the file, as provided by the Content-Length
/// header. If this header was not provided, the value is
/// <code>NSURLSessionTransferSizeUnknown</code>.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
/// Tells the delegate that the download task has resumed downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that resumed. See explanation in the discussion.
///
/// \param fileOffset If the file’s cache policy or last modified date prevents reuse of the
/// existing content, then this value is zero. Otherwise, this value is an
/// integer representing the number of bytes on disk that do not need to be
/// retrieved again.
///
/// \param expectedTotalBytes The expected length of the file, as provided by the Content-Length header.
/// If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
@end

@class NSURLAuthenticationChallenge;
@class NSURLCredential;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDelegate>
/// Tells the delegate that the session has been invalidated.
/// \param session The session object that was invalidated.
///
/// \param error The error that caused invalidation, or nil if the invalidation was explicit.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
/// Requests credentials from the delegate in response to a session-level authentication request from the
/// remote server.
/// \param session The session containing the task that requested authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate that all messages enqueued for a session have been delivered.
/// \param session The session that no longer has any outstanding requests.
///
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * _Nonnull)session;
@end

@class NSURLSessionDataTask;
@class NSURLResponse;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDataDelegate>
/// Tells the delegate that the data task received the initial reply (headers) from the server.
/// \param session The session containing the data task that received an initial reply.
///
/// \param dataTask The data task that received an initial reply.
///
/// \param response A URL response object populated with headers.
///
/// \param completionHandler A completion handler that your code calls to continue the transfer, passing a
/// constant to indicate whether the transfer should continue as a data task or
/// should become a download task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveResponse:(NSURLResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(NSURLSessionResponseDisposition))completionHandler;
/// Tells the delegate that the data task was changed to a download task.
/// \param session The session containing the task that was replaced by a download task.
///
/// \param dataTask The data task that was replaced by a download task.
///
/// \param downloadTask The new download task that replaced the data task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask;
/// Tells the delegate that the data task has received some of the expected data.
/// \param session The session containing the data task that provided data.
///
/// \param dataTask The data task that provided data.
///
/// \param data A data object containing the transferred data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
/// Asks the delegate whether the data (or upload) task should store the response in the cache.
/// \param session The session containing the data (or upload) task.
///
/// \param dataTask The data (or upload) task.
///
/// \param proposedResponse The default caching behavior. This behavior is determined based on the current
/// caching policy and the values of certain received headers, such as the Pragma
/// and Cache-Control headers.
///
/// \param completionHandler A block that your handler must call, providing either the original proposed
/// response, a modified version of that response, or NULL to prevent caching the
/// response. If your delegate implements this method, it must call this completion
/// handler; otherwise, your app leaks memory.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionStreamTask;
@class NSInputStream;
@class NSOutputStream;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionStreamDelegate>
/// Tells the delegate that the read side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session readClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the write side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session writeClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the system has determined that a better route to the host is available.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session betterRouteDiscoveredForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
/// \param session The session.
///
/// \param streamTask The stream task.
///
/// \param inputStream The new input stream.
///
/// \param outputStream The new output stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session streamTask:(NSURLSessionStreamTask * _Nonnull)streamTask didBecomeInputStream:(NSInputStream * _Nonnull)inputStream outputStream:(NSOutputStream * _Nonnull)outputStream;
@end

@class NSURLSessionTask;
@class NSHTTPURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionTaskDelegate>
/// Tells the delegate that the remote server requested an HTTP redirect.
/// \param session The session containing the task whose request resulted in a redirect.
///
/// \param task The task whose request resulted in a redirect.
///
/// \param response An object containing the server’s response to the original request.
///
/// \param request A URL request object filled out with the new location.
///
/// \param completionHandler A closure that your handler should call with either the value of the request
/// parameter, a modified URL request object, or NULL to refuse the redirect and
/// return the body of the redirect response.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
/// Requests credentials from the delegate in response to an authentication request from the remote server.
/// \param session The session containing the task whose request requires authentication.
///
/// \param task The task whose request requires authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate when a task requires a new request body stream to send to the remote server.
/// \param session The session containing the task that needs a new body stream.
///
/// \param task The task that needs a new body stream.
///
/// \param completionHandler A completion handler that your delegate method should call with the new body stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
/// Periodically informs the delegate of the progress of sending body content to the server.
/// \param session The session containing the data task.
///
/// \param task The data task.
///
/// \param bytesSent The number of bytes sent since the last time this delegate method was called.
///
/// \param totalBytesSent The total number of bytes sent so far.
///
/// \param totalBytesExpectedToSend The expected length of the body data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
/// Tells the delegate that the task finished transferring data.
/// \param session The session containing the task whose request finished transferring data.
///
/// \param task The task whose request finished transferring data.
///
/// \param error If an error occurred, an error object indicating how the transfer failed, otherwise nil.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
@end


/// The task delegate is responsible for handling all delegate callbacks for the underlying task as well as
/// executing all operations attached to the serial operation queue upon task completion.
SWIFT_CLASS("_TtC7GeoUniq12TaskDelegate")
@interface TaskDelegate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end











#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__i386__) && __i386__
// Generated by Apple Swift version 5.0.1 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreMotion;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeoUniq",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, ConsentItem, closed) {
  ConsentItemCustomization = 0,
  ConsentItemAnalisys = 1,
};


SWIFT_CLASS("_TtC7GeoUniq11ConsentsMap")
@interface ConsentsMap : NSObject
- (BOOL)containsValueWithValue:(BOOL)value SWIFT_WARN_UNUSED_RESULT;
- (BOOL)getWithKey:(enum ConsentItem)key SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Object which describe the configuration of the http request when forwarding locations
SWIFT_CLASS("_TtC7GeoUniq14CustomEndpoint")
@interface CustomEndpoint : NSObject
/// url for the request
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// dictionary representing the headers of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable headers;
/// dictionary representing the query string parameters of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable queryStringParameters;
/// object which will be delivered together with the locations
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable customData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class delegate to the build of <code>CustomEndpoint</code> Objects.
/// First create a CustomEndpointBuilder instance: <code>CustomEndpointBuilder()</code>, then add every parameter you need: url, headers, query string parameters and custom data
/// The custom data is an object which will be delivered with the location
/// Example: let customEndPoint = CustomEndpointBuilder().setUrl(‘http://dodo.com’).setHeader(key: ‘token’, value: ‘Bearer empty’).build()
/// Remember: if you set an http url insted of an https you have to enable it into the Info.plist file.
SWIFT_CLASS("_TtC7GeoUniq21CustomEndpointBuilder")
@interface CustomEndpointBuilder : NSObject
/// Instantiate the builder
///
/// returns:
/// the object created
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Instantiate the builder with the given CustomEndpoint
/// \param customEndpoint existing customEndpoint
///
///
/// returns:
/// the object created
- (nonnull instancetype)initWithCustomEndpoint:(CustomEndpoint * _Nonnull)customEndpoint OBJC_DESIGNATED_INITIALIZER;
/// Set the url for the <code>CustomEndpoint</code> object
/// \param url http/s url
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidUrlException
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setUrlWithUrl:(NSString * _Nonnull)url error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set a single header value
/// \param key key of the header
///
/// \param value value of the header
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeaderWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Remove an heder value given the key
/// \param key the key to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeHeaderWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set all the header to be used in the <code>CustomEndpoint</code>. All the previously set header parameter will be replaced
/// \param headers dictionary of the headers
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeadersWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers SWIFT_WARN_UNUSED_RESULT;
/// Remove all the headers set
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllHeaders SWIFT_WARN_UNUSED_RESULT;
/// Add a query string parameter
/// \param key key of the parameter
///
/// \param value value of the parameter
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParameterWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Set the query string parameters, all the previously set will be replaced
/// \param parameters parameters dicionary
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParametersWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters SWIFT_WARN_UNUSED_RESULT;
/// Remove a single query string parameter
/// \param key key of the parameter to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeQueryStringParameterWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Remove all the query string parameters
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllQueryStringParameters SWIFT_WARN_UNUSED_RESULT;
/// Set the custom date. This object will be sent together with the location object.
/// It has to be a valid JSON serializable object, an error will be thrown otherwise.
/// Serializability is check with the method: <code>JSONSerialization.isValidJSONObject(data)</code>
/// \param data custom object
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidJSONObject
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setCustomDataWithData:(NSDictionary<NSString *, id> * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Remove the previously set custom data, if any
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeCustomData SWIFT_WARN_UNUSED_RESULT;
/// Enable or disable the forwarding locations with the custom enpoint
/// \param enabled boolean
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setEnabledWithEnabled:(BOOL)enabled SWIFT_WARN_UNUSED_RESULT;
/// Build and return the <code>CustomEndpoint</code> built with the set parameters
///
/// throws:
/// CustomEndpoint.NoUrlDefinedException
///
/// returns:
/// the <code>CustomEndpoint</code> object correctly built
- (CustomEndpoint * _Nullable)buildAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// Exceptions defining errors during the build of the CustomEndpoint with the Builder
typedef SWIFT_ENUM(NSInteger, CustomEndpointException, closed) {
/// Invalid url exception
  CustomEndpointExceptionInvalidUrlException = 0,
/// No url defined
  CustomEndpointExceptionNoUrlDefinedException = 1,
/// Invalid Json Object
  CustomEndpointExceptionInvalidJSONObject = 2,
};
static NSString * _Nonnull const CustomEndpointExceptionDomain = @"GeoUniq.CustomEndpointException";

@class GUMotionActivity;

/// Delegate to implement in order to receive the callback for the change of activity event
SWIFT_PROTOCOL("_TtP7GeoUniq18GUActivityDelegate_")
@protocol GUActivityDelegate
/// Public constructor
- (nonnull instancetype)init;
/// Called on activity change
/// \param started new activity that triggered the event
///
/// \param finished previous activity
///
- (void)onActivityChangedWithStarted:(GUMotionActivity * _Nonnull)started finished:(GUMotionActivity * _Nonnull)finished;
@end

@class GUGeoPoint;

/// Represents a circular area.
SWIFT_CLASS("_TtC7GeoUniq14GUCircularArea")
@interface GUCircularArea : NSObject <NSCopying>
/// The center of the circle
@property (nonatomic, strong) GUGeoPoint * _Nonnull center;
/// The radius of the circle
@property (nonatomic) double radius;
/// The name of the area
@property (nonatomic, copy) NSString * _Nullable name;
/// The description of the area
@property (nonatomic, copy) NSString * _Nullable areaDescription;
/// Public constructor
/// \param center The center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithCenter:(GUGeoPoint * _Nonnull)center radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
/// Public constructor
/// \param latitude latitude of the center of the circle
///
/// \param longitude longitude of the center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Enumeration describing generic error
typedef SWIFT_ENUM(NSInteger, GUError, closed) {
/// The permission of the localization service has been denied, no location will be delivered
  GUErrorDeniedLocalizationPermission = 0,
/// The permission of the localization service has not yet been granted, the locations will arrive when the permission will be granted.
  GUErrorNotDeterminedLocalizationPermission = 1,
/// A general/unknown error occurred
  GUErrorGeneralError = 2,
/// The Location updates has not been request in <code>background modes</code> section
  GUErrorBackgroundLocationUpdates = 3,
};


/// Represents a geographical point through the latitide and longitude coordinates.
SWIFT_CLASS("_TtC7GeoUniq10GUGeoPoint")
@interface GUGeoPoint : NSObject
/// latitude of the point
@property (nonatomic) double latitude;
/// longitude of the point
@property (nonatomic) double longitude;
/// Public constructor
/// \param latitude latitude of the point
///
/// \param longitude longitude of the point
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface GUGeoPoint (SWIFT_EXTENSION(GeoUniq)) <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end



enum Status : NSInteger;

/// Represents a geographical area that is monitored with the associated callback class. These objects are returned when calling the func <code>setGUGeofence()</code>, <code>getAllGUGeofence()</code>
SWIFT_CLASS("_TtC7GeoUniq10GUGeofence")
@interface GUGeofence : NSObject
/// A unique id for the <code>GUGeofence</code> Object. It can be used to remove a Geofence through the func <code>removeGUGeonfece()</code>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The area that is being monitored
@property (nonatomic, readonly, strong) GUCircularArea * _Nonnull area;
/// The name of the class that will receive callbacks when the device enters and exits the monitored area, according to the <code>GUGeofenceListener</code> protocol
@property (nonatomic, readonly, copy) NSString * _Nonnull callBackClass;
/// <code>GUGeofence.Status</code> of the geofence when the Object is obtained
@property (nonatomic, readonly) enum Status status;
/// Expiration date of the geofence, after this date the geofence will be deleted
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// Date of last status change
@property (nonatomic, readonly, copy) NSDate * _Nullable lastStatusChange;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, Status, closed) {
/// UNKNOWN
///
/// returns:
/// Inidcates that it was not possible to determine whether the device is iside or outside the monitored area. This Status is possible only when the position of the device has never been obtained.
  StatusUNKNOWN = 0,
/// INSIDE
///
/// returns:
/// indicates that the device is inside the monitored area
  StatusINSIDE = 1,
/// OUTSIDE
///
/// returns:
/// indicates that the device is outside the monitored area
  StatusOUTSIDE = 2,
};




/// Defines the callback functions called when a device enters or exits a <code>GUGeofence</code>.
/// This protocol has to be adopted by the class associated to a <code>GUGeofence</code> object <code>setGUGeofence()</code>
SWIFT_PROTOCOL("_TtP7GeoUniq18GUGeofenceListener_")
@protocol GUGeofenceListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when the device enters the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didEnterGUGeofence:(GUGeofence * _Nonnull)geofence;
/// Called when the device exits the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didExitGUGeofence:(GUGeofence * _Nonnull)geofence;
@end

@class NSNumber;

/// Object which wrap the location resulting in: latitude, longitude, time and motion activity
SWIFT_CLASS("_TtC7GeoUniq10GULocation")
@interface GULocation : NSObject
/// latitude of the location
@property (nonatomic) double latitude;
/// longitude of the location
@property (nonatomic) double longitude;
/// time of the location
@property (nonatomic, copy) NSDate * _Nonnull time;
/// motionActivity of the location
@property (nonatomic, copy) NSString * _Nonnull motionActivity;
/// visit duration of the location in seconds
@property (nonatomic) double visitDuration;
/// accuracy
@property (nonatomic, strong) NSNumber * _Nullable accuracy;
/// Public constructor
/// \param latitude latitude of the location
///
/// \param longitude logitude of the location
///
/// \param time time of the location
///
/// \param motionActivity motionActivity of the location
///
/// \param accuracy accuracy of the location
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude time:(NSDate * _Nonnull)time motionActivity:(NSString * _Nonnull)motionActivity confirmedAt:(NSDate * _Nonnull)confirmedAt accuracy:(NSNumber * _Nullable)accuracy OBJC_DESIGNATED_INITIALIZER;
/// Obtain a representation of the location in the form:
/// “latitude”: Double
/// “longitude”: Double
/// “time”: NSDate
/// “motionActivity”: String
/// “accuracy”: NSNumber
- (NSDictionary<NSString *, id> * _Nonnull)getGULocation SWIFT_WARN_UNUSED_RESULT;
/// Return the description in a json serialization form
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Protocol to implement in order to receive callbakcs about location history
SWIFT_PROTOCOL("_TtP7GeoUniq25GULocationHistoryReceiver_")
@protocol GULocationHistoryReceiver
/// Callback method called to return the list of positions retrieved form GeoUniq Analytics cloud platform
/// \param locations list of Locations object
///
- (void)onSuccess:(NSArray<GULocation *> * _Nonnull)locations;
/// Callback method called when an error occurs during the communication with GeoUniq Analytics cloud platform.
- (void)onError;
@end

enum GUMotionType : NSInteger;

/// Models a motion activity, that is, a period of time during which the same motion type (see <code>GUMotionType</code>) has been observed
SWIFT_CLASS("_TtC7GeoUniq16GUMotionActivity")
@interface GUMotionActivity : NSObject
/// Allows to obtain the <code>GUMotionType</code> of movement of this GUMotionActivity
@property (nonatomic, readonly) enum GUMotionType type;
/// Allows to obtain the start time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
/// Allows to obtain the end time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nullable endTime;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Enumeration that describe the activity of the user
typedef SWIFT_ENUM(NSInteger, GUMotionType, closed) {
/// Not Moving
///
/// returns:
/// not moving activity
  GUMotionTypeStill = 0,
/// Walking
///
/// returns:
/// walking activity
  GUMotionTypeWalking = 1,
/// Running
///
/// returns:
/// running activity
  GUMotionTypeRunning = 2,
/// cycling
///
/// returns:
/// cycling activity
  GUMotionTypeCycling = 3,
/// Automotive
///
/// returns:
/// automotive activity
  GUMotionTypeAutomotive = 4,
/// Unknown
///
/// returns:
/// unknown activity
  GUMotionTypeUnknown = 5,
};

@class CLLocation;
@class NSError;

/// Delegate to implement in order to receive the locations when the app is suspended
SWIFT_PROTOCOL("_TtP7GeoUniq18GUOfflineStreaming_")
@protocol GUOfflineStreaming
/// Public constructor
- (nonnull instancetype)init;
/// Called on new location detected
/// \param location new location detected
///
- (void)newLocationReceived:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUPositionReceiver_")
@protocol GUPositionReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive the locations in streaming
SWIFT_PROTOCOL("_TtP7GeoUniq17GUOnlineStreaming_")
@protocol GUOnlineStreaming <GUPositionReceiver>
/// Return a value identifying the Object. This is use to avoid replication when registering for a streaming
///
/// returns:
/// <#return value description#>
- (NSString * _Nonnull)getIdentifier SWIFT_WARN_UNUSED_RESULT;
@end



/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GURealTimeReceiver_")
@protocol GURealTimeReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(enum GUError)guError error:(NSError * _Nullable)error;
@end

/// Enumeration which provide you the different values of sort
/// <ul>
///   <li>
///     timestampAsc: Sort by ascending timestamp
///   </li>
///   <li>
///     timestampDes: Sort by descending timestamp
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GUSort, closed) {
/// Sort by ascending time
  GUSortTimeAsc = 0,
/// Sort by descending time
  GUSortTimeDesc = 1,
};


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUTrackingListener_")
@protocol GUTrackingListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onNewLocationUpdate:(GULocation * _Nonnull)location;
@end


/// GeoUniq class. Every method can be accessed by the sharedInstance() method. The very first time call the method setMobileKey(mobileKey: String) to authenticate the device and start the tracking.
SWIFT_CLASS("_TtC7GeoUniq7GeoUniq")
@interface GeoUniq : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_CUSTOM_ID_LENGTH;)
+ (NSInteger)MAX_CUSTOM_ID_LENGTH SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Obtain the version name of GeoUniq framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull FrameworkVersionName;)
+ (NSString * _Nonnull)FrameworkVersionName SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq. You will also notify about the device-id
/// \param callbackDeviceId function callback where you will be notify about the device-id
///
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance:(void (^ _Nonnull)(NSString * _Nonnull))callbackDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Return the mobileKeykey in the info.plist file or nil if none
///
/// returns:
/// the mobileKey provided
- (NSString * _Nullable)getMobileKey SWIFT_WARN_UNUSED_RESULT;
/// Return the id relative to the device if it has been registered, nil otherwise.
/// You should handle the device id in the callback of the sharedInstance() method
///
/// returns:
/// the device id if available or nil otherwise
- (NSString * _Nullable)getDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Enable the tracking of the device.
/// If the tracking is running this method has no influence on the system.
- (void)enable;
/// Disable the tracking of the device (until the application is not killed)
/// It will restart when explicitly call start() method or sharedInstance(…) if the key GUAutoStartedTracking is set to true
- (void)disable;
/// Return the starting granularity if the basic tracking is set to true, nil otherwise
/// If the basic tracking is set to true but no accuracy has been provided, will be returned the default granularity (10000)
///
/// returns:
/// the starting granularity in meters
- (double)getStartingTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking
/// \param granularity set the starting granularity in meters
///
- (void)setStartingTrackingGranularity:(double)granularity;
/// Reset the value to the one provided in the Info.plist file
- (void)resetStartingTrackingGranularity;
/// Return the granularity of the current tracking session(until the app is killed)
///
/// returns:
/// granularity for the current tracking session
- (double)getCurrentTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking of this session (until the app is killed), then will be used the starting accuracy provided if the service is open
/// \param granularity the granularity in meters for the current tracking session
///
- (void)setCurrentTrackingGranularity:(double)granularity;
/// Ask GeoUniq for a location with the given accuracy.
/// \param accuracy accuracy requested for the position
///
/// \param callback class delegate to receive the location
///
- (void)getPosition:(double)accuracy callback:(id <GUPositionReceiver> _Nonnull)callback;
/// Allow the print of the log for warnings and errors
/// \param enable true if you want to print out the logs
///
- (void)enableDebug:(BOOL)enable;
/// Return true if the tracking is active
///
/// returns:
/// boolean
- (BOOL)isTrackingActive SWIFT_WARN_UNUSED_RESULT;
/// Call on the background fetch event of the device
- (void)backgroundFetch;
/// Register the application for the background fetch with the minimum interval (UIApplicationBackgroundFetchIntervalMinimum)
- (void)registerBackgroundFetch;
/// Register the device to receive remote notifications, if the iOS version is older than 8.0.0 register the device for Badge, Alert and Sounds. You Will receive the device token in the application:didRegisterForRemoteNotificationsWithDeviceToken method, or in application:didReceiveRemoteNotification in case of errors; remember to forward the deviceToken to GeoUniq service with the method ‘registerDeviceToken(deviceToken: NSData)’
- (void)registerRemoteNotifications;
/// Forward the device token received by the application:didRegisterForRemoteNotificationsWithDeviceToken method
/// \param deviceToken token provided by iOS
///
- (void)registerDeviceToken:(NSData * _Nonnull)deviceToken;
/// Set the label for the tracking session. The value will label all future positions on the server until you explicitelly change it or reset it.
/// The max String length is 10000 characters.
/// \param label label you want to assing to the tracking session
///
///
/// returns:
/// true if the string could used for the label
- (BOOL)setLabelSession:(NSString * _Nullable)label SWIFT_WARN_UNUSED_RESULT;
/// Get the label for the tracking session
///
/// returns:
/// the label for the tracking session
- (NSString * _Nullable)getLabelSession SWIFT_WARN_UNUSED_RESULT;
/// Reset the label to the default value (nil)
- (void)resetLabel;
/// Request motion activity permission for use the hardaware chip
- (void)requestMotionActivityPermission;
/// Get motion activity permission status (aviable only from iOS 11)
///
/// returns:
/// the current authorization status
- (CMAuthorizationStatus)getMotionActivityPermission SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=11.0);
/// Return the current motion activity (the last detected)
///
/// returns:
/// the current activity
- (GUMotionActivity * _Nullable)getCurrentActivity SWIFT_WARN_UNUSED_RESULT;
/// Get privacy consent status
- (BOOL)getConsentStatus SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "getPrivacyConsents");
/// set privacy consent status
- (void)setConsentStatusWithIsGranted:(BOOL)isGranted SWIFT_DEPRECATED_MSG("", "setPrivacyConsent");
/// show pop-up for privacy consent ask and set status
/// -returns: completion isGranted (Bool)
- (void)showConsentDialogAndSetWithCompletion:(void (^ _Nonnull)(BOOL))completion SWIFT_DEPRECATED_MSG("", "showPrivacyPolicyAndSetWithCompletion:");
- (void)showPrivacyPolicyAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)showPrivacyPolicySwitchesAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)setPrivacyConsent:(enum ConsentItem)consent value:(BOOL)value;
- (BOOL)getPrivacyConsent:(enum ConsentItem)consent SWIFT_WARN_UNUSED_RESULT;
- (ConsentsMap * _Nonnull)getPrivacyConsentsMap SWIFT_WARN_UNUSED_RESULT;
/// Obtain the last location registered
- (GULocation * _Nullable)getLastKnownLocation SWIFT_WARN_UNUSED_RESULT;
/// Obtain the location history of the device given a timeframe and a type of sort
/// \param from start time frame
///
/// \param to end of the time frame
///
/// \param sort type of sort for the locations
///
/// \param locationsReceiver callback on which the locations will be delivered
///
- (void)getLocationHistory:(NSDate * _Nonnull)from to:(NSDate * _Nonnull)to sort:(enum GUSort)sort locationsReceiver:(id <GULocationHistoryReceiver> _Nonnull)locationsReceiver;
/// Allows to register this Device to all the Groups whose name is equal to the parameter
/// \param name indicating the name of the Group(s) of interest
///
- (void)registerToGroupsWithName:(NSString * _Nonnull)name;
/// Allows to register this Device to the Group whose ID is equal to the parameter
/// \param groupId indicating the ID of the Group of interest
///
- (void)registerToGroupWithId:(NSString * _Nonnull)groupId;
/// Store the Cusom Endpoint Object to use for the Location forwarding.
/// In order to create the <code>CustomEndpoint</code> object use <code>CustomEndpoint.Builder</code>, it will allow you to build correctly the <code>CustomEndpoint</code>.
/// After this method remember to call <code>.enableCustomEndpoint()</code> in order to enable the forward of locations
/// \param endpoint representation of the parameters of the call
///
- (void)setCustomEndpointWithEndpoint:(CustomEndpoint * _Nonnull)endpoint;
/// Return the <code>CustomEndpoint</code> in use
///
/// returns:
/// custom endpoint
- (CustomEndpoint * _Nullable)getCustomEndpoint SWIFT_WARN_UNUSED_RESULT;
/// Remove the ´CustomEnpoint´ in use, this command will disable the forwards of locations
- (void)removeCustomEndpoint;
/// Enable the forward of locations using the parameters in the <code>CustomEnpoint</code> stored
- (void)enableCustomEndpoint;
/// Disable the forward of locations, the <code>CustomEndpoint</code> is still stored for a later use
- (void)disableCustomEndpoint;
/// Return the current state of the forwarding locations to a custom endpoint: enabled or disabled
///
/// returns:
/// boolean
- (BOOL)isCustomEndpointEnabled SWIFT_WARN_UNUSED_RESULT;
/// Check if the tracking is possible on this device, the parameters checked are:
/// <ul>
///   <li>
///     location permission granted or not determined
///   </li>
///   <li>
///     parameters in Info.plist file correctly provided
///   </li>
/// </ul>
/// In addition will be logged (if enabled) the status of permission
///
/// returns:
/// the possibility to track the device
- (BOOL)isLocationTrackingAvailable SWIFT_WARN_UNUSED_RESULT;
/// Register a delegate to receive all the locations update, even in background
/// \param listener listener to register
///
- (void)setTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener;
/// Remove a registered delegate for locations update
/// \param listener registered listener
///
///
/// returns:
/// true if a argument listener exists. False otherwise.
- (BOOL)removeTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener SWIFT_WARN_UNUSED_RESULT;
/// Allows to obtain the set listeners
///
/// returns:
/// <code>[GUTrackingListener.Type]</code>
- (NSArray<Class <GUTrackingListener>> * _Nullable)getTrackingListeners SWIFT_WARN_UNUSED_RESULT;
/// Removes all listener previously set
- (void)removeAllTrackingListeners;
- (BOOL)setCustomId:(NSString * _Nonnull)customId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCustomId SWIFT_WARN_UNUSED_RESULT;
/// Sets  a <code>GUGeofence</code> for the geographical area indicated by area argument
/// and the callback class indicated by the listener argument
/// \param area A <code>GUCircularArea</code> representing the circular area to be monitored
///
/// \param listener A class adopting the <code>GUGeofenceListener</code> protocol
///
/// \param expirationDate Expiration date of the <code>GUGeofence</code>, after this date the <code>GUGeofence</code> will be deleted
///
///
/// returns:
/// the created <code>GUGeofence</code> object
- (GUGeofence * _Nonnull)setGUGeofenceWithArea:(GUCircularArea * _Nonnull)area listener:(Class <GUGeofenceListener> _Nonnull)listener expirationDate:(NSDate * _Nullable)expirationDate SWIFT_WARN_UNUSED_RESULT;
/// Removes the <code>GUGeofence</code> with id equal to the <code>id</code> argument, if any.
/// \param id the id of the <code>GUGeofence</code> to be removed
///
///
/// returns:
/// true if a <code>GUGeofence</code> with the provided id exists. False otherwise.
- (BOOL)removeGUGeofenceWithId:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Removes all <code>GUGeofence</code> previously set
- (void)removeAllGUGeofence;
/// Allows to obtain the set <code>GUGeofence</code> objects
///
/// returns:
/// <code>[GUGeofence]</code>
- (NSArray<GUGeofence *> * _Nonnull)getGUGeofences SWIFT_WARN_UNUSED_RESULT;
- (NSArray<GUGeofence *> * _Nonnull)getRemoteGUGeofences SWIFT_WARN_UNUSED_RESULT;
@end


/// Responsible for handling all delegate callbacks for the underlying session.
SWIFT_CLASS("_TtC7GeoUniq15SessionDelegate")
@interface SessionDelegate : NSObject
/// Initializes the <code>SessionDelegate</code> instance.
///
/// returns:
/// The new <code>SessionDelegate</code> instance.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Returns a <code>Bool</code> indicating whether the <code>SessionDelegate</code> implements or inherits a method that can respond
/// to a specified message.
/// \param selector A selector that identifies a message.
///
///
/// returns:
/// <code>true</code> if the receiver implements or inherits a method that can respond to selector, otherwise <code>false</code>.
- (BOOL)respondsToSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
@end

@class NSURLSession;
@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDownloadDelegate>
/// Tells the delegate that a download task has finished downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that finished.
///
/// \param location A file URL for the temporary file. Because the file is temporary, you must either
/// open the file for reading or move it to a permanent location in your app’s sandbox
/// container directory before returning from this delegate method.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
/// Periodically informs the delegate about the download’s progress.
/// \param session The session containing the download task.
///
/// \param downloadTask The download task.
///
/// \param bytesWritten The number of bytes transferred since the last time this delegate
/// method was called.
///
/// \param totalBytesWritten The total number of bytes transferred so far.
///
/// \param totalBytesExpectedToWrite The expected length of the file, as provided by the Content-Length
/// header. If this header was not provided, the value is
/// <code>NSURLSessionTransferSizeUnknown</code>.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
/// Tells the delegate that the download task has resumed downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that resumed. See explanation in the discussion.
///
/// \param fileOffset If the file’s cache policy or last modified date prevents reuse of the
/// existing content, then this value is zero. Otherwise, this value is an
/// integer representing the number of bytes on disk that do not need to be
/// retrieved again.
///
/// \param expectedTotalBytes The expected length of the file, as provided by the Content-Length header.
/// If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
@end

@class NSURLAuthenticationChallenge;
@class NSURLCredential;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDelegate>
/// Tells the delegate that the session has been invalidated.
/// \param session The session object that was invalidated.
///
/// \param error The error that caused invalidation, or nil if the invalidation was explicit.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
/// Requests credentials from the delegate in response to a session-level authentication request from the
/// remote server.
/// \param session The session containing the task that requested authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate that all messages enqueued for a session have been delivered.
/// \param session The session that no longer has any outstanding requests.
///
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * _Nonnull)session;
@end

@class NSURLSessionDataTask;
@class NSURLResponse;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDataDelegate>
/// Tells the delegate that the data task received the initial reply (headers) from the server.
/// \param session The session containing the data task that received an initial reply.
///
/// \param dataTask The data task that received an initial reply.
///
/// \param response A URL response object populated with headers.
///
/// \param completionHandler A completion handler that your code calls to continue the transfer, passing a
/// constant to indicate whether the transfer should continue as a data task or
/// should become a download task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveResponse:(NSURLResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(NSURLSessionResponseDisposition))completionHandler;
/// Tells the delegate that the data task was changed to a download task.
/// \param session The session containing the task that was replaced by a download task.
///
/// \param dataTask The data task that was replaced by a download task.
///
/// \param downloadTask The new download task that replaced the data task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask;
/// Tells the delegate that the data task has received some of the expected data.
/// \param session The session containing the data task that provided data.
///
/// \param dataTask The data task that provided data.
///
/// \param data A data object containing the transferred data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
/// Asks the delegate whether the data (or upload) task should store the response in the cache.
/// \param session The session containing the data (or upload) task.
///
/// \param dataTask The data (or upload) task.
///
/// \param proposedResponse The default caching behavior. This behavior is determined based on the current
/// caching policy and the values of certain received headers, such as the Pragma
/// and Cache-Control headers.
///
/// \param completionHandler A block that your handler must call, providing either the original proposed
/// response, a modified version of that response, or NULL to prevent caching the
/// response. If your delegate implements this method, it must call this completion
/// handler; otherwise, your app leaks memory.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionStreamTask;
@class NSInputStream;
@class NSOutputStream;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionStreamDelegate>
/// Tells the delegate that the read side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session readClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the write side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session writeClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the system has determined that a better route to the host is available.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session betterRouteDiscoveredForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
/// \param session The session.
///
/// \param streamTask The stream task.
///
/// \param inputStream The new input stream.
///
/// \param outputStream The new output stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session streamTask:(NSURLSessionStreamTask * _Nonnull)streamTask didBecomeInputStream:(NSInputStream * _Nonnull)inputStream outputStream:(NSOutputStream * _Nonnull)outputStream;
@end

@class NSURLSessionTask;
@class NSHTTPURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionTaskDelegate>
/// Tells the delegate that the remote server requested an HTTP redirect.
/// \param session The session containing the task whose request resulted in a redirect.
///
/// \param task The task whose request resulted in a redirect.
///
/// \param response An object containing the server’s response to the original request.
///
/// \param request A URL request object filled out with the new location.
///
/// \param completionHandler A closure that your handler should call with either the value of the request
/// parameter, a modified URL request object, or NULL to refuse the redirect and
/// return the body of the redirect response.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
/// Requests credentials from the delegate in response to an authentication request from the remote server.
/// \param session The session containing the task whose request requires authentication.
///
/// \param task The task whose request requires authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate when a task requires a new request body stream to send to the remote server.
/// \param session The session containing the task that needs a new body stream.
///
/// \param task The task that needs a new body stream.
///
/// \param completionHandler A completion handler that your delegate method should call with the new body stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
/// Periodically informs the delegate of the progress of sending body content to the server.
/// \param session The session containing the data task.
///
/// \param task The data task.
///
/// \param bytesSent The number of bytes sent since the last time this delegate method was called.
///
/// \param totalBytesSent The total number of bytes sent so far.
///
/// \param totalBytesExpectedToSend The expected length of the body data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
/// Tells the delegate that the task finished transferring data.
/// \param session The session containing the task whose request finished transferring data.
///
/// \param task The task whose request finished transferring data.
///
/// \param error If an error occurred, an error object indicating how the transfer failed, otherwise nil.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
@end


/// The task delegate is responsible for handling all delegate callbacks for the underlying task as well as
/// executing all operations attached to the serial operation queue upon task completion.
SWIFT_CLASS("_TtC7GeoUniq12TaskDelegate")
@interface TaskDelegate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end











#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
#else
//Start of iphoneos
#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.0.1 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreMotion;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeoUniq",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, ConsentItem, closed) {
  ConsentItemCustomization = 0,
  ConsentItemAnalisys = 1,
};


SWIFT_CLASS("_TtC7GeoUniq11ConsentsMap")
@interface ConsentsMap : NSObject
- (BOOL)containsValueWithValue:(BOOL)value SWIFT_WARN_UNUSED_RESULT;
- (BOOL)getWithKey:(enum ConsentItem)key SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Object which describe the configuration of the http request when forwarding locations
SWIFT_CLASS("_TtC7GeoUniq14CustomEndpoint")
@interface CustomEndpoint : NSObject
/// url for the request
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// dictionary representing the headers of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable headers;
/// dictionary representing the query string parameters of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable queryStringParameters;
/// object which will be delivered together with the locations
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable customData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class delegate to the build of <code>CustomEndpoint</code> Objects.
/// First create a CustomEndpointBuilder instance: <code>CustomEndpointBuilder()</code>, then add every parameter you need: url, headers, query string parameters and custom data
/// The custom data is an object which will be delivered with the location
/// Example: let customEndPoint = CustomEndpointBuilder().setUrl(‘http://dodo.com’).setHeader(key: ‘token’, value: ‘Bearer empty’).build()
/// Remember: if you set an http url insted of an https you have to enable it into the Info.plist file.
SWIFT_CLASS("_TtC7GeoUniq21CustomEndpointBuilder")
@interface CustomEndpointBuilder : NSObject
/// Instantiate the builder
///
/// returns:
/// the object created
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Instantiate the builder with the given CustomEndpoint
/// \param customEndpoint existing customEndpoint
///
///
/// returns:
/// the object created
- (nonnull instancetype)initWithCustomEndpoint:(CustomEndpoint * _Nonnull)customEndpoint OBJC_DESIGNATED_INITIALIZER;
/// Set the url for the <code>CustomEndpoint</code> object
/// \param url http/s url
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidUrlException
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setUrlWithUrl:(NSString * _Nonnull)url error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set a single header value
/// \param key key of the header
///
/// \param value value of the header
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeaderWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Remove an heder value given the key
/// \param key the key to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeHeaderWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set all the header to be used in the <code>CustomEndpoint</code>. All the previously set header parameter will be replaced
/// \param headers dictionary of the headers
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeadersWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers SWIFT_WARN_UNUSED_RESULT;
/// Remove all the headers set
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllHeaders SWIFT_WARN_UNUSED_RESULT;
/// Add a query string parameter
/// \param key key of the parameter
///
/// \param value value of the parameter
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParameterWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Set the query string parameters, all the previously set will be replaced
/// \param parameters parameters dicionary
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParametersWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters SWIFT_WARN_UNUSED_RESULT;
/// Remove a single query string parameter
/// \param key key of the parameter to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeQueryStringParameterWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Remove all the query string parameters
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllQueryStringParameters SWIFT_WARN_UNUSED_RESULT;
/// Set the custom date. This object will be sent together with the location object.
/// It has to be a valid JSON serializable object, an error will be thrown otherwise.
/// Serializability is check with the method: <code>JSONSerialization.isValidJSONObject(data)</code>
/// \param data custom object
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidJSONObject
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setCustomDataWithData:(NSDictionary<NSString *, id> * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Remove the previously set custom data, if any
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeCustomData SWIFT_WARN_UNUSED_RESULT;
/// Enable or disable the forwarding locations with the custom enpoint
/// \param enabled boolean
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setEnabledWithEnabled:(BOOL)enabled SWIFT_WARN_UNUSED_RESULT;
/// Build and return the <code>CustomEndpoint</code> built with the set parameters
///
/// throws:
/// CustomEndpoint.NoUrlDefinedException
///
/// returns:
/// the <code>CustomEndpoint</code> object correctly built
- (CustomEndpoint * _Nullable)buildAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// Exceptions defining errors during the build of the CustomEndpoint with the Builder
typedef SWIFT_ENUM(NSInteger, CustomEndpointException, closed) {
/// Invalid url exception
  CustomEndpointExceptionInvalidUrlException = 0,
/// No url defined
  CustomEndpointExceptionNoUrlDefinedException = 1,
/// Invalid Json Object
  CustomEndpointExceptionInvalidJSONObject = 2,
};
static NSString * _Nonnull const CustomEndpointExceptionDomain = @"GeoUniq.CustomEndpointException";

@class GUMotionActivity;

/// Delegate to implement in order to receive the callback for the change of activity event
SWIFT_PROTOCOL("_TtP7GeoUniq18GUActivityDelegate_")
@protocol GUActivityDelegate
/// Public constructor
- (nonnull instancetype)init;
/// Called on activity change
/// \param started new activity that triggered the event
///
/// \param finished previous activity
///
- (void)onActivityChangedWithStarted:(GUMotionActivity * _Nonnull)started finished:(GUMotionActivity * _Nonnull)finished;
@end

@class GUGeoPoint;

/// Represents a circular area.
SWIFT_CLASS("_TtC7GeoUniq14GUCircularArea")
@interface GUCircularArea : NSObject <NSCopying>
/// The center of the circle
@property (nonatomic, strong) GUGeoPoint * _Nonnull center;
/// The radius of the circle
@property (nonatomic) double radius;
/// The name of the area
@property (nonatomic, copy) NSString * _Nullable name;
/// The description of the area
@property (nonatomic, copy) NSString * _Nullable areaDescription;
/// Public constructor
/// \param center The center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithCenter:(GUGeoPoint * _Nonnull)center radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
/// Public constructor
/// \param latitude latitude of the center of the circle
///
/// \param longitude longitude of the center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Enumeration describing generic error
typedef SWIFT_ENUM(NSInteger, GUError, closed) {
/// The permission of the localization service has been denied, no location will be delivered
  GUErrorDeniedLocalizationPermission = 0,
/// The permission of the localization service has not yet been granted, the locations will arrive when the permission will be granted.
  GUErrorNotDeterminedLocalizationPermission = 1,
/// A general/unknown error occurred
  GUErrorGeneralError = 2,
/// The Location updates has not been request in <code>background modes</code> section
  GUErrorBackgroundLocationUpdates = 3,
};


/// Represents a geographical point through the latitide and longitude coordinates.
SWIFT_CLASS("_TtC7GeoUniq10GUGeoPoint")
@interface GUGeoPoint : NSObject
/// latitude of the point
@property (nonatomic) double latitude;
/// longitude of the point
@property (nonatomic) double longitude;
/// Public constructor
/// \param latitude latitude of the point
///
/// \param longitude longitude of the point
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface GUGeoPoint (SWIFT_EXTENSION(GeoUniq)) <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end



enum Status : NSInteger;

/// Represents a geographical area that is monitored with the associated callback class. These objects are returned when calling the func <code>setGUGeofence()</code>, <code>getAllGUGeofence()</code>
SWIFT_CLASS("_TtC7GeoUniq10GUGeofence")
@interface GUGeofence : NSObject
/// A unique id for the <code>GUGeofence</code> Object. It can be used to remove a Geofence through the func <code>removeGUGeonfece()</code>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The area that is being monitored
@property (nonatomic, readonly, strong) GUCircularArea * _Nonnull area;
/// The name of the class that will receive callbacks when the device enters and exits the monitored area, according to the <code>GUGeofenceListener</code> protocol
@property (nonatomic, readonly, copy) NSString * _Nonnull callBackClass;
/// <code>GUGeofence.Status</code> of the geofence when the Object is obtained
@property (nonatomic, readonly) enum Status status;
/// Expiration date of the geofence, after this date the geofence will be deleted
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// Date of last status change
@property (nonatomic, readonly, copy) NSDate * _Nullable lastStatusChange;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, Status, closed) {
/// UNKNOWN
///
/// returns:
/// Inidcates that it was not possible to determine whether the device is iside or outside the monitored area. This Status is possible only when the position of the device has never been obtained.
  StatusUNKNOWN = 0,
/// INSIDE
///
/// returns:
/// indicates that the device is inside the monitored area
  StatusINSIDE = 1,
/// OUTSIDE
///
/// returns:
/// indicates that the device is outside the monitored area
  StatusOUTSIDE = 2,
};




/// Defines the callback functions called when a device enters or exits a <code>GUGeofence</code>.
/// This protocol has to be adopted by the class associated to a <code>GUGeofence</code> object <code>setGUGeofence()</code>
SWIFT_PROTOCOL("_TtP7GeoUniq18GUGeofenceListener_")
@protocol GUGeofenceListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when the device enters the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didEnterGUGeofence:(GUGeofence * _Nonnull)geofence;
/// Called when the device exits the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didExitGUGeofence:(GUGeofence * _Nonnull)geofence;
@end

@class NSNumber;

/// Object which wrap the location resulting in: latitude, longitude, time and motion activity
SWIFT_CLASS("_TtC7GeoUniq10GULocation")
@interface GULocation : NSObject
/// latitude of the location
@property (nonatomic) double latitude;
/// longitude of the location
@property (nonatomic) double longitude;
/// time of the location
@property (nonatomic, copy) NSDate * _Nonnull time;
/// motionActivity of the location
@property (nonatomic, copy) NSString * _Nonnull motionActivity;
/// visit duration of the location in seconds
@property (nonatomic) double visitDuration;
/// accuracy
@property (nonatomic, strong) NSNumber * _Nullable accuracy;
/// Public constructor
/// \param latitude latitude of the location
///
/// \param longitude logitude of the location
///
/// \param time time of the location
///
/// \param motionActivity motionActivity of the location
///
/// \param accuracy accuracy of the location
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude time:(NSDate * _Nonnull)time motionActivity:(NSString * _Nonnull)motionActivity confirmedAt:(NSDate * _Nonnull)confirmedAt accuracy:(NSNumber * _Nullable)accuracy OBJC_DESIGNATED_INITIALIZER;
/// Obtain a representation of the location in the form:
/// “latitude”: Double
/// “longitude”: Double
/// “time”: NSDate
/// “motionActivity”: String
/// “accuracy”: NSNumber
- (NSDictionary<NSString *, id> * _Nonnull)getGULocation SWIFT_WARN_UNUSED_RESULT;
/// Return the description in a json serialization form
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Protocol to implement in order to receive callbakcs about location history
SWIFT_PROTOCOL("_TtP7GeoUniq25GULocationHistoryReceiver_")
@protocol GULocationHistoryReceiver
/// Callback method called to return the list of positions retrieved form GeoUniq Analytics cloud platform
/// \param locations list of Locations object
///
- (void)onSuccess:(NSArray<GULocation *> * _Nonnull)locations;
/// Callback method called when an error occurs during the communication with GeoUniq Analytics cloud platform.
- (void)onError;
@end

enum GUMotionType : NSInteger;

/// Models a motion activity, that is, a period of time during which the same motion type (see <code>GUMotionType</code>) has been observed
SWIFT_CLASS("_TtC7GeoUniq16GUMotionActivity")
@interface GUMotionActivity : NSObject
/// Allows to obtain the <code>GUMotionType</code> of movement of this GUMotionActivity
@property (nonatomic, readonly) enum GUMotionType type;
/// Allows to obtain the start time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
/// Allows to obtain the end time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nullable endTime;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Enumeration that describe the activity of the user
typedef SWIFT_ENUM(NSInteger, GUMotionType, closed) {
/// Not Moving
///
/// returns:
/// not moving activity
  GUMotionTypeStill = 0,
/// Walking
///
/// returns:
/// walking activity
  GUMotionTypeWalking = 1,
/// Running
///
/// returns:
/// running activity
  GUMotionTypeRunning = 2,
/// cycling
///
/// returns:
/// cycling activity
  GUMotionTypeCycling = 3,
/// Automotive
///
/// returns:
/// automotive activity
  GUMotionTypeAutomotive = 4,
/// Unknown
///
/// returns:
/// unknown activity
  GUMotionTypeUnknown = 5,
};

@class CLLocation;
@class NSError;

/// Delegate to implement in order to receive the locations when the app is suspended
SWIFT_PROTOCOL("_TtP7GeoUniq18GUOfflineStreaming_")
@protocol GUOfflineStreaming
/// Public constructor
- (nonnull instancetype)init;
/// Called on new location detected
/// \param location new location detected
///
- (void)newLocationReceived:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUPositionReceiver_")
@protocol GUPositionReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive the locations in streaming
SWIFT_PROTOCOL("_TtP7GeoUniq17GUOnlineStreaming_")
@protocol GUOnlineStreaming <GUPositionReceiver>
/// Return a value identifying the Object. This is use to avoid replication when registering for a streaming
///
/// returns:
/// <#return value description#>
- (NSString * _Nonnull)getIdentifier SWIFT_WARN_UNUSED_RESULT;
@end



/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GURealTimeReceiver_")
@protocol GURealTimeReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(enum GUError)guError error:(NSError * _Nullable)error;
@end

/// Enumeration which provide you the different values of sort
/// <ul>
///   <li>
///     timestampAsc: Sort by ascending timestamp
///   </li>
///   <li>
///     timestampDes: Sort by descending timestamp
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GUSort, closed) {
/// Sort by ascending time
  GUSortTimeAsc = 0,
/// Sort by descending time
  GUSortTimeDesc = 1,
};


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUTrackingListener_")
@protocol GUTrackingListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onNewLocationUpdate:(GULocation * _Nonnull)location;
@end


/// GeoUniq class. Every method can be accessed by the sharedInstance() method. The very first time call the method setMobileKey(mobileKey: String) to authenticate the device and start the tracking.
SWIFT_CLASS("_TtC7GeoUniq7GeoUniq")
@interface GeoUniq : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_CUSTOM_ID_LENGTH;)
+ (NSInteger)MAX_CUSTOM_ID_LENGTH SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Obtain the version name of GeoUniq framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull FrameworkVersionName;)
+ (NSString * _Nonnull)FrameworkVersionName SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq. You will also notify about the device-id
/// \param callbackDeviceId function callback where you will be notify about the device-id
///
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance:(void (^ _Nonnull)(NSString * _Nonnull))callbackDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Return the mobileKeykey in the info.plist file or nil if none
///
/// returns:
/// the mobileKey provided
- (NSString * _Nullable)getMobileKey SWIFT_WARN_UNUSED_RESULT;
/// Return the id relative to the device if it has been registered, nil otherwise.
/// You should handle the device id in the callback of the sharedInstance() method
///
/// returns:
/// the device id if available or nil otherwise
- (NSString * _Nullable)getDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Enable the tracking of the device.
/// If the tracking is running this method has no influence on the system.
- (void)enable;
/// Disable the tracking of the device (until the application is not killed)
/// It will restart when explicitly call start() method or sharedInstance(…) if the key GUAutoStartedTracking is set to true
- (void)disable;
/// Return the starting granularity if the basic tracking is set to true, nil otherwise
/// If the basic tracking is set to true but no accuracy has been provided, will be returned the default granularity (10000)
///
/// returns:
/// the starting granularity in meters
- (double)getStartingTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking
/// \param granularity set the starting granularity in meters
///
- (void)setStartingTrackingGranularity:(double)granularity;
/// Reset the value to the one provided in the Info.plist file
- (void)resetStartingTrackingGranularity;
/// Return the granularity of the current tracking session(until the app is killed)
///
/// returns:
/// granularity for the current tracking session
- (double)getCurrentTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking of this session (until the app is killed), then will be used the starting accuracy provided if the service is open
/// \param granularity the granularity in meters for the current tracking session
///
- (void)setCurrentTrackingGranularity:(double)granularity;
/// Ask GeoUniq for a location with the given accuracy.
/// \param accuracy accuracy requested for the position
///
/// \param callback class delegate to receive the location
///
- (void)getPosition:(double)accuracy callback:(id <GUPositionReceiver> _Nonnull)callback;
/// Allow the print of the log for warnings and errors
/// \param enable true if you want to print out the logs
///
- (void)enableDebug:(BOOL)enable;
/// Return true if the tracking is active
///
/// returns:
/// boolean
- (BOOL)isTrackingActive SWIFT_WARN_UNUSED_RESULT;
/// Call on the background fetch event of the device
- (void)backgroundFetch;
/// Register the application for the background fetch with the minimum interval (UIApplicationBackgroundFetchIntervalMinimum)
- (void)registerBackgroundFetch;
/// Register the device to receive remote notifications, if the iOS version is older than 8.0.0 register the device for Badge, Alert and Sounds. You Will receive the device token in the application:didRegisterForRemoteNotificationsWithDeviceToken method, or in application:didReceiveRemoteNotification in case of errors; remember to forward the deviceToken to GeoUniq service with the method ‘registerDeviceToken(deviceToken: NSData)’
- (void)registerRemoteNotifications;
/// Forward the device token received by the application:didRegisterForRemoteNotificationsWithDeviceToken method
/// \param deviceToken token provided by iOS
///
- (void)registerDeviceToken:(NSData * _Nonnull)deviceToken;
/// Set the label for the tracking session. The value will label all future positions on the server until you explicitelly change it or reset it.
/// The max String length is 10000 characters.
/// \param label label you want to assing to the tracking session
///
///
/// returns:
/// true if the string could used for the label
- (BOOL)setLabelSession:(NSString * _Nullable)label SWIFT_WARN_UNUSED_RESULT;
/// Get the label for the tracking session
///
/// returns:
/// the label for the tracking session
- (NSString * _Nullable)getLabelSession SWIFT_WARN_UNUSED_RESULT;
/// Reset the label to the default value (nil)
- (void)resetLabel;
/// Request motion activity permission for use the hardaware chip
- (void)requestMotionActivityPermission;
/// Get motion activity permission status (aviable only from iOS 11)
///
/// returns:
/// the current authorization status
- (CMAuthorizationStatus)getMotionActivityPermission SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=11.0);
/// Return the current motion activity (the last detected)
///
/// returns:
/// the current activity
- (GUMotionActivity * _Nullable)getCurrentActivity SWIFT_WARN_UNUSED_RESULT;
/// Get privacy consent status
- (BOOL)getConsentStatus SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "getPrivacyConsents");
/// set privacy consent status
- (void)setConsentStatusWithIsGranted:(BOOL)isGranted SWIFT_DEPRECATED_MSG("", "setPrivacyConsent");
/// show pop-up for privacy consent ask and set status
/// -returns: completion isGranted (Bool)
- (void)showConsentDialogAndSetWithCompletion:(void (^ _Nonnull)(BOOL))completion SWIFT_DEPRECATED_MSG("", "showPrivacyPolicyAndSetWithCompletion:");
- (void)showPrivacyPolicyAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)showPrivacyPolicySwitchesAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)setPrivacyConsent:(enum ConsentItem)consent value:(BOOL)value;
- (BOOL)getPrivacyConsent:(enum ConsentItem)consent SWIFT_WARN_UNUSED_RESULT;
- (ConsentsMap * _Nonnull)getPrivacyConsentsMap SWIFT_WARN_UNUSED_RESULT;
/// Obtain the last location registered
- (GULocation * _Nullable)getLastKnownLocation SWIFT_WARN_UNUSED_RESULT;
/// Obtain the location history of the device given a timeframe and a type of sort
/// \param from start time frame
///
/// \param to end of the time frame
///
/// \param sort type of sort for the locations
///
/// \param locationsReceiver callback on which the locations will be delivered
///
- (void)getLocationHistory:(NSDate * _Nonnull)from to:(NSDate * _Nonnull)to sort:(enum GUSort)sort locationsReceiver:(id <GULocationHistoryReceiver> _Nonnull)locationsReceiver;
/// Allows to register this Device to all the Groups whose name is equal to the parameter
/// \param name indicating the name of the Group(s) of interest
///
- (void)registerToGroupsWithName:(NSString * _Nonnull)name;
/// Allows to register this Device to the Group whose ID is equal to the parameter
/// \param groupId indicating the ID of the Group of interest
///
- (void)registerToGroupWithId:(NSString * _Nonnull)groupId;
/// Store the Cusom Endpoint Object to use for the Location forwarding.
/// In order to create the <code>CustomEndpoint</code> object use <code>CustomEndpoint.Builder</code>, it will allow you to build correctly the <code>CustomEndpoint</code>.
/// After this method remember to call <code>.enableCustomEndpoint()</code> in order to enable the forward of locations
/// \param endpoint representation of the parameters of the call
///
- (void)setCustomEndpointWithEndpoint:(CustomEndpoint * _Nonnull)endpoint;
/// Return the <code>CustomEndpoint</code> in use
///
/// returns:
/// custom endpoint
- (CustomEndpoint * _Nullable)getCustomEndpoint SWIFT_WARN_UNUSED_RESULT;
/// Remove the ´CustomEnpoint´ in use, this command will disable the forwards of locations
- (void)removeCustomEndpoint;
/// Enable the forward of locations using the parameters in the <code>CustomEnpoint</code> stored
- (void)enableCustomEndpoint;
/// Disable the forward of locations, the <code>CustomEndpoint</code> is still stored for a later use
- (void)disableCustomEndpoint;
/// Return the current state of the forwarding locations to a custom endpoint: enabled or disabled
///
/// returns:
/// boolean
- (BOOL)isCustomEndpointEnabled SWIFT_WARN_UNUSED_RESULT;
/// Check if the tracking is possible on this device, the parameters checked are:
/// <ul>
///   <li>
///     location permission granted or not determined
///   </li>
///   <li>
///     parameters in Info.plist file correctly provided
///   </li>
/// </ul>
/// In addition will be logged (if enabled) the status of permission
///
/// returns:
/// the possibility to track the device
- (BOOL)isLocationTrackingAvailable SWIFT_WARN_UNUSED_RESULT;
/// Register a delegate to receive all the locations update, even in background
/// \param listener listener to register
///
- (void)setTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener;
/// Remove a registered delegate for locations update
/// \param listener registered listener
///
///
/// returns:
/// true if a argument listener exists. False otherwise.
- (BOOL)removeTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener SWIFT_WARN_UNUSED_RESULT;
/// Allows to obtain the set listeners
///
/// returns:
/// <code>[GUTrackingListener.Type]</code>
- (NSArray<Class <GUTrackingListener>> * _Nullable)getTrackingListeners SWIFT_WARN_UNUSED_RESULT;
/// Removes all listener previously set
- (void)removeAllTrackingListeners;
- (BOOL)setCustomId:(NSString * _Nonnull)customId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCustomId SWIFT_WARN_UNUSED_RESULT;
/// Sets  a <code>GUGeofence</code> for the geographical area indicated by area argument
/// and the callback class indicated by the listener argument
/// \param area A <code>GUCircularArea</code> representing the circular area to be monitored
///
/// \param listener A class adopting the <code>GUGeofenceListener</code> protocol
///
/// \param expirationDate Expiration date of the <code>GUGeofence</code>, after this date the <code>GUGeofence</code> will be deleted
///
///
/// returns:
/// the created <code>GUGeofence</code> object
- (GUGeofence * _Nonnull)setGUGeofenceWithArea:(GUCircularArea * _Nonnull)area listener:(Class <GUGeofenceListener> _Nonnull)listener expirationDate:(NSDate * _Nullable)expirationDate SWIFT_WARN_UNUSED_RESULT;
/// Removes the <code>GUGeofence</code> with id equal to the <code>id</code> argument, if any.
/// \param id the id of the <code>GUGeofence</code> to be removed
///
///
/// returns:
/// true if a <code>GUGeofence</code> with the provided id exists. False otherwise.
- (BOOL)removeGUGeofenceWithId:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Removes all <code>GUGeofence</code> previously set
- (void)removeAllGUGeofence;
/// Allows to obtain the set <code>GUGeofence</code> objects
///
/// returns:
/// <code>[GUGeofence]</code>
- (NSArray<GUGeofence *> * _Nonnull)getGUGeofences SWIFT_WARN_UNUSED_RESULT;
- (NSArray<GUGeofence *> * _Nonnull)getRemoteGUGeofences SWIFT_WARN_UNUSED_RESULT;
@end


/// Responsible for handling all delegate callbacks for the underlying session.
SWIFT_CLASS("_TtC7GeoUniq15SessionDelegate")
@interface SessionDelegate : NSObject
/// Initializes the <code>SessionDelegate</code> instance.
///
/// returns:
/// The new <code>SessionDelegate</code> instance.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Returns a <code>Bool</code> indicating whether the <code>SessionDelegate</code> implements or inherits a method that can respond
/// to a specified message.
/// \param selector A selector that identifies a message.
///
///
/// returns:
/// <code>true</code> if the receiver implements or inherits a method that can respond to selector, otherwise <code>false</code>.
- (BOOL)respondsToSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
@end

@class NSURLSession;
@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDownloadDelegate>
/// Tells the delegate that a download task has finished downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that finished.
///
/// \param location A file URL for the temporary file. Because the file is temporary, you must either
/// open the file for reading or move it to a permanent location in your app’s sandbox
/// container directory before returning from this delegate method.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
/// Periodically informs the delegate about the download’s progress.
/// \param session The session containing the download task.
///
/// \param downloadTask The download task.
///
/// \param bytesWritten The number of bytes transferred since the last time this delegate
/// method was called.
///
/// \param totalBytesWritten The total number of bytes transferred so far.
///
/// \param totalBytesExpectedToWrite The expected length of the file, as provided by the Content-Length
/// header. If this header was not provided, the value is
/// <code>NSURLSessionTransferSizeUnknown</code>.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
/// Tells the delegate that the download task has resumed downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that resumed. See explanation in the discussion.
///
/// \param fileOffset If the file’s cache policy or last modified date prevents reuse of the
/// existing content, then this value is zero. Otherwise, this value is an
/// integer representing the number of bytes on disk that do not need to be
/// retrieved again.
///
/// \param expectedTotalBytes The expected length of the file, as provided by the Content-Length header.
/// If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
@end

@class NSURLAuthenticationChallenge;
@class NSURLCredential;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDelegate>
/// Tells the delegate that the session has been invalidated.
/// \param session The session object that was invalidated.
///
/// \param error The error that caused invalidation, or nil if the invalidation was explicit.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
/// Requests credentials from the delegate in response to a session-level authentication request from the
/// remote server.
/// \param session The session containing the task that requested authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate that all messages enqueued for a session have been delivered.
/// \param session The session that no longer has any outstanding requests.
///
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * _Nonnull)session;
@end

@class NSURLSessionDataTask;
@class NSURLResponse;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDataDelegate>
/// Tells the delegate that the data task received the initial reply (headers) from the server.
/// \param session The session containing the data task that received an initial reply.
///
/// \param dataTask The data task that received an initial reply.
///
/// \param response A URL response object populated with headers.
///
/// \param completionHandler A completion handler that your code calls to continue the transfer, passing a
/// constant to indicate whether the transfer should continue as a data task or
/// should become a download task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveResponse:(NSURLResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(NSURLSessionResponseDisposition))completionHandler;
/// Tells the delegate that the data task was changed to a download task.
/// \param session The session containing the task that was replaced by a download task.
///
/// \param dataTask The data task that was replaced by a download task.
///
/// \param downloadTask The new download task that replaced the data task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask;
/// Tells the delegate that the data task has received some of the expected data.
/// \param session The session containing the data task that provided data.
///
/// \param dataTask The data task that provided data.
///
/// \param data A data object containing the transferred data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
/// Asks the delegate whether the data (or upload) task should store the response in the cache.
/// \param session The session containing the data (or upload) task.
///
/// \param dataTask The data (or upload) task.
///
/// \param proposedResponse The default caching behavior. This behavior is determined based on the current
/// caching policy and the values of certain received headers, such as the Pragma
/// and Cache-Control headers.
///
/// \param completionHandler A block that your handler must call, providing either the original proposed
/// response, a modified version of that response, or NULL to prevent caching the
/// response. If your delegate implements this method, it must call this completion
/// handler; otherwise, your app leaks memory.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionStreamTask;
@class NSInputStream;
@class NSOutputStream;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionStreamDelegate>
/// Tells the delegate that the read side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session readClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the write side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session writeClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the system has determined that a better route to the host is available.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session betterRouteDiscoveredForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
/// \param session The session.
///
/// \param streamTask The stream task.
///
/// \param inputStream The new input stream.
///
/// \param outputStream The new output stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session streamTask:(NSURLSessionStreamTask * _Nonnull)streamTask didBecomeInputStream:(NSInputStream * _Nonnull)inputStream outputStream:(NSOutputStream * _Nonnull)outputStream;
@end

@class NSURLSessionTask;
@class NSHTTPURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionTaskDelegate>
/// Tells the delegate that the remote server requested an HTTP redirect.
/// \param session The session containing the task whose request resulted in a redirect.
///
/// \param task The task whose request resulted in a redirect.
///
/// \param response An object containing the server’s response to the original request.
///
/// \param request A URL request object filled out with the new location.
///
/// \param completionHandler A closure that your handler should call with either the value of the request
/// parameter, a modified URL request object, or NULL to refuse the redirect and
/// return the body of the redirect response.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
/// Requests credentials from the delegate in response to an authentication request from the remote server.
/// \param session The session containing the task whose request requires authentication.
///
/// \param task The task whose request requires authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate when a task requires a new request body stream to send to the remote server.
/// \param session The session containing the task that needs a new body stream.
///
/// \param task The task that needs a new body stream.
///
/// \param completionHandler A completion handler that your delegate method should call with the new body stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
/// Periodically informs the delegate of the progress of sending body content to the server.
/// \param session The session containing the data task.
///
/// \param task The data task.
///
/// \param bytesSent The number of bytes sent since the last time this delegate method was called.
///
/// \param totalBytesSent The total number of bytes sent so far.
///
/// \param totalBytesExpectedToSend The expected length of the body data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
/// Tells the delegate that the task finished transferring data.
/// \param session The session containing the task whose request finished transferring data.
///
/// \param task The task whose request finished transferring data.
///
/// \param error If an error occurred, an error object indicating how the transfer failed, otherwise nil.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
@end


/// The task delegate is responsible for handling all delegate callbacks for the underlying task as well as
/// executing all operations attached to the serial operation queue upon task completion.
SWIFT_CLASS("_TtC7GeoUniq12TaskDelegate")
@interface TaskDelegate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end











#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.0.1 (swiftlang-1001.0.82.4 clang-1001.0.46.5)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreMotion;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeoUniq",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, ConsentItem, closed) {
  ConsentItemCustomization = 0,
  ConsentItemAnalisys = 1,
};


SWIFT_CLASS("_TtC7GeoUniq11ConsentsMap")
@interface ConsentsMap : NSObject
- (BOOL)containsValueWithValue:(BOOL)value SWIFT_WARN_UNUSED_RESULT;
- (BOOL)getWithKey:(enum ConsentItem)key SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Object which describe the configuration of the http request when forwarding locations
SWIFT_CLASS("_TtC7GeoUniq14CustomEndpoint")
@interface CustomEndpoint : NSObject
/// url for the request
@property (nonatomic, readonly, copy) NSString * _Nullable url;
/// dictionary representing the headers of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable headers;
/// dictionary representing the query string parameters of the request
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable queryStringParameters;
/// object which will be delivered together with the locations
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable customData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class delegate to the build of <code>CustomEndpoint</code> Objects.
/// First create a CustomEndpointBuilder instance: <code>CustomEndpointBuilder()</code>, then add every parameter you need: url, headers, query string parameters and custom data
/// The custom data is an object which will be delivered with the location
/// Example: let customEndPoint = CustomEndpointBuilder().setUrl(‘http://dodo.com’).setHeader(key: ‘token’, value: ‘Bearer empty’).build()
/// Remember: if you set an http url insted of an https you have to enable it into the Info.plist file.
SWIFT_CLASS("_TtC7GeoUniq21CustomEndpointBuilder")
@interface CustomEndpointBuilder : NSObject
/// Instantiate the builder
///
/// returns:
/// the object created
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Instantiate the builder with the given CustomEndpoint
/// \param customEndpoint existing customEndpoint
///
///
/// returns:
/// the object created
- (nonnull instancetype)initWithCustomEndpoint:(CustomEndpoint * _Nonnull)customEndpoint OBJC_DESIGNATED_INITIALIZER;
/// Set the url for the <code>CustomEndpoint</code> object
/// \param url http/s url
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidUrlException
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setUrlWithUrl:(NSString * _Nonnull)url error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Set a single header value
/// \param key key of the header
///
/// \param value value of the header
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeaderWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Remove an heder value given the key
/// \param key the key to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeHeaderWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Set all the header to be used in the <code>CustomEndpoint</code>. All the previously set header parameter will be replaced
/// \param headers dictionary of the headers
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setHeadersWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers SWIFT_WARN_UNUSED_RESULT;
/// Remove all the headers set
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllHeaders SWIFT_WARN_UNUSED_RESULT;
/// Add a query string parameter
/// \param key key of the parameter
///
/// \param value value of the parameter
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParameterWithKey:(NSString * _Nonnull)key value:(NSString * _Nonnull)value SWIFT_WARN_UNUSED_RESULT;
/// Set the query string parameters, all the previously set will be replaced
/// \param parameters parameters dicionary
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setQueryStringParametersWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters SWIFT_WARN_UNUSED_RESULT;
/// Remove a single query string parameter
/// \param key key of the parameter to be removed
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeQueryStringParameterWithKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Remove all the query string parameters
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeAllQueryStringParameters SWIFT_WARN_UNUSED_RESULT;
/// Set the custom date. This object will be sent together with the location object.
/// It has to be a valid JSON serializable object, an error will be thrown otherwise.
/// Serializability is check with the method: <code>JSONSerialization.isValidJSONObject(data)</code>
/// \param data custom object
///
///
/// throws:
/// CustomEndpoint.Exception.InvalidJSONObject
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nullable)setCustomDataWithData:(NSDictionary<NSString *, id> * _Nonnull)data error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Remove the previously set custom data, if any
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)removeCustomData SWIFT_WARN_UNUSED_RESULT;
/// Enable or disable the forwarding locations with the custom enpoint
/// \param enabled boolean
///
///
/// returns:
/// the builder object
- (CustomEndpointBuilder * _Nonnull)setEnabledWithEnabled:(BOOL)enabled SWIFT_WARN_UNUSED_RESULT;
/// Build and return the <code>CustomEndpoint</code> built with the set parameters
///
/// throws:
/// CustomEndpoint.NoUrlDefinedException
///
/// returns:
/// the <code>CustomEndpoint</code> object correctly built
- (CustomEndpoint * _Nullable)buildAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// Exceptions defining errors during the build of the CustomEndpoint with the Builder
typedef SWIFT_ENUM(NSInteger, CustomEndpointException, closed) {
/// Invalid url exception
  CustomEndpointExceptionInvalidUrlException = 0,
/// No url defined
  CustomEndpointExceptionNoUrlDefinedException = 1,
/// Invalid Json Object
  CustomEndpointExceptionInvalidJSONObject = 2,
};
static NSString * _Nonnull const CustomEndpointExceptionDomain = @"GeoUniq.CustomEndpointException";

@class GUMotionActivity;

/// Delegate to implement in order to receive the callback for the change of activity event
SWIFT_PROTOCOL("_TtP7GeoUniq18GUActivityDelegate_")
@protocol GUActivityDelegate
/// Public constructor
- (nonnull instancetype)init;
/// Called on activity change
/// \param started new activity that triggered the event
///
/// \param finished previous activity
///
- (void)onActivityChangedWithStarted:(GUMotionActivity * _Nonnull)started finished:(GUMotionActivity * _Nonnull)finished;
@end

@class GUGeoPoint;

/// Represents a circular area.
SWIFT_CLASS("_TtC7GeoUniq14GUCircularArea")
@interface GUCircularArea : NSObject <NSCopying>
/// The center of the circle
@property (nonatomic, strong) GUGeoPoint * _Nonnull center;
/// The radius of the circle
@property (nonatomic) double radius;
/// The name of the area
@property (nonatomic, copy) NSString * _Nullable name;
/// The description of the area
@property (nonatomic, copy) NSString * _Nullable areaDescription;
/// Public constructor
/// \param center The center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithCenter:(GUGeoPoint * _Nonnull)center radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
/// Public constructor
/// \param latitude latitude of the center of the circle
///
/// \param longitude longitude of the center of the circle
///
/// \param radius The radius of the circle
///
/// \param name A optional name for the area
///
/// \param areaDescription A optional dscription for the area
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude radius:(double)radius name:(NSString * _Nullable)name areaDescription:(NSString * _Nullable)areaDescription OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Enumeration describing generic error
typedef SWIFT_ENUM(NSInteger, GUError, closed) {
/// The permission of the localization service has been denied, no location will be delivered
  GUErrorDeniedLocalizationPermission = 0,
/// The permission of the localization service has not yet been granted, the locations will arrive when the permission will be granted.
  GUErrorNotDeterminedLocalizationPermission = 1,
/// A general/unknown error occurred
  GUErrorGeneralError = 2,
/// The Location updates has not been request in <code>background modes</code> section
  GUErrorBackgroundLocationUpdates = 3,
};


/// Represents a geographical point through the latitide and longitude coordinates.
SWIFT_CLASS("_TtC7GeoUniq10GUGeoPoint")
@interface GUGeoPoint : NSObject
/// latitude of the point
@property (nonatomic) double latitude;
/// longitude of the point
@property (nonatomic) double longitude;
/// Public constructor
/// \param latitude latitude of the point
///
/// \param longitude longitude of the point
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface GUGeoPoint (SWIFT_EXTENSION(GeoUniq)) <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end



enum Status : NSInteger;

/// Represents a geographical area that is monitored with the associated callback class. These objects are returned when calling the func <code>setGUGeofence()</code>, <code>getAllGUGeofence()</code>
SWIFT_CLASS("_TtC7GeoUniq10GUGeofence")
@interface GUGeofence : NSObject
/// A unique id for the <code>GUGeofence</code> Object. It can be used to remove a Geofence through the func <code>removeGUGeonfece()</code>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The area that is being monitored
@property (nonatomic, readonly, strong) GUCircularArea * _Nonnull area;
/// The name of the class that will receive callbacks when the device enters and exits the monitored area, according to the <code>GUGeofenceListener</code> protocol
@property (nonatomic, readonly, copy) NSString * _Nonnull callBackClass;
/// <code>GUGeofence.Status</code> of the geofence when the Object is obtained
@property (nonatomic, readonly) enum Status status;
/// Expiration date of the geofence, after this date the geofence will be deleted
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// Date of last status change
@property (nonatomic, readonly, copy) NSDate * _Nullable lastStatusChange;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, Status, closed) {
/// UNKNOWN
///
/// returns:
/// Inidcates that it was not possible to determine whether the device is iside or outside the monitored area. This Status is possible only when the position of the device has never been obtained.
  StatusUNKNOWN = 0,
/// INSIDE
///
/// returns:
/// indicates that the device is inside the monitored area
  StatusINSIDE = 1,
/// OUTSIDE
///
/// returns:
/// indicates that the device is outside the monitored area
  StatusOUTSIDE = 2,
};




/// Defines the callback functions called when a device enters or exits a <code>GUGeofence</code>.
/// This protocol has to be adopted by the class associated to a <code>GUGeofence</code> object <code>setGUGeofence()</code>
SWIFT_PROTOCOL("_TtP7GeoUniq18GUGeofenceListener_")
@protocol GUGeofenceListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when the device enters the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didEnterGUGeofence:(GUGeofence * _Nonnull)geofence;
/// Called when the device exits the monitored area
/// \param geofence the <code>GUGeofence</code> which the callback refers to
///
- (void)didExitGUGeofence:(GUGeofence * _Nonnull)geofence;
@end

@class NSNumber;

/// Object which wrap the location resulting in: latitude, longitude, time and motion activity
SWIFT_CLASS("_TtC7GeoUniq10GULocation")
@interface GULocation : NSObject
/// latitude of the location
@property (nonatomic) double latitude;
/// longitude of the location
@property (nonatomic) double longitude;
/// time of the location
@property (nonatomic, copy) NSDate * _Nonnull time;
/// motionActivity of the location
@property (nonatomic, copy) NSString * _Nonnull motionActivity;
/// visit duration of the location in seconds
@property (nonatomic) double visitDuration;
/// accuracy
@property (nonatomic, strong) NSNumber * _Nullable accuracy;
/// Public constructor
/// \param latitude latitude of the location
///
/// \param longitude logitude of the location
///
/// \param time time of the location
///
/// \param motionActivity motionActivity of the location
///
/// \param accuracy accuracy of the location
///
- (nonnull instancetype)initWithLatitude:(double)latitude longitude:(double)longitude time:(NSDate * _Nonnull)time motionActivity:(NSString * _Nonnull)motionActivity confirmedAt:(NSDate * _Nonnull)confirmedAt accuracy:(NSNumber * _Nullable)accuracy OBJC_DESIGNATED_INITIALIZER;
/// Obtain a representation of the location in the form:
/// “latitude”: Double
/// “longitude”: Double
/// “time”: NSDate
/// “motionActivity”: String
/// “accuracy”: NSNumber
- (NSDictionary<NSString *, id> * _Nonnull)getGULocation SWIFT_WARN_UNUSED_RESULT;
/// Return the description in a json serialization form
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Protocol to implement in order to receive callbakcs about location history
SWIFT_PROTOCOL("_TtP7GeoUniq25GULocationHistoryReceiver_")
@protocol GULocationHistoryReceiver
/// Callback method called to return the list of positions retrieved form GeoUniq Analytics cloud platform
/// \param locations list of Locations object
///
- (void)onSuccess:(NSArray<GULocation *> * _Nonnull)locations;
/// Callback method called when an error occurs during the communication with GeoUniq Analytics cloud platform.
- (void)onError;
@end

enum GUMotionType : NSInteger;

/// Models a motion activity, that is, a period of time during which the same motion type (see <code>GUMotionType</code>) has been observed
SWIFT_CLASS("_TtC7GeoUniq16GUMotionActivity")
@interface GUMotionActivity : NSObject
/// Allows to obtain the <code>GUMotionType</code> of movement of this GUMotionActivity
@property (nonatomic, readonly) enum GUMotionType type;
/// Allows to obtain the start time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
/// Allows to obtain the end time of this GUMotionActivity
@property (nonatomic, readonly, copy) NSDate * _Nullable endTime;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Enumeration that describe the activity of the user
typedef SWIFT_ENUM(NSInteger, GUMotionType, closed) {
/// Not Moving
///
/// returns:
/// not moving activity
  GUMotionTypeStill = 0,
/// Walking
///
/// returns:
/// walking activity
  GUMotionTypeWalking = 1,
/// Running
///
/// returns:
/// running activity
  GUMotionTypeRunning = 2,
/// cycling
///
/// returns:
/// cycling activity
  GUMotionTypeCycling = 3,
/// Automotive
///
/// returns:
/// automotive activity
  GUMotionTypeAutomotive = 4,
/// Unknown
///
/// returns:
/// unknown activity
  GUMotionTypeUnknown = 5,
};

@class CLLocation;
@class NSError;

/// Delegate to implement in order to receive the locations when the app is suspended
SWIFT_PROTOCOL("_TtP7GeoUniq18GUOfflineStreaming_")
@protocol GUOfflineStreaming
/// Public constructor
- (nonnull instancetype)init;
/// Called on new location detected
/// \param location new location detected
///
- (void)newLocationReceived:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUPositionReceiver_")
@protocol GUPositionReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(NSError * _Nonnull)error;
@end


/// Delegate to implement in order to receive the locations in streaming
SWIFT_PROTOCOL("_TtP7GeoUniq17GUOnlineStreaming_")
@protocol GUOnlineStreaming <GUPositionReceiver>
/// Return a value identifying the Object. This is use to avoid replication when registering for a streaming
///
/// returns:
/// <#return value description#>
- (NSString * _Nonnull)getIdentifier SWIFT_WARN_UNUSED_RESULT;
@end



/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GURealTimeReceiver_")
@protocol GURealTimeReceiver
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onPositionListened:(CLLocation * _Nonnull)location;
/// Called when was not possible obtain a location
/// \param error description of the error
///
- (void)onError:(enum GUError)guError error:(NSError * _Nullable)error;
@end

/// Enumeration which provide you the different values of sort
/// <ul>
///   <li>
///     timestampAsc: Sort by ascending timestamp
///   </li>
///   <li>
///     timestampDes: Sort by descending timestamp
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GUSort, closed) {
/// Sort by ascending time
  GUSortTimeAsc = 0,
/// Sort by descending time
  GUSortTimeDesc = 1,
};


/// Delegate to implement in order to receive callbacks for the single location request or for the streaming feature
SWIFT_PROTOCOL("_TtP7GeoUniq18GUTrackingListener_")
@protocol GUTrackingListener
/// Public constructor
- (nonnull instancetype)init;
/// Called when a new location is received
/// \param location location received
///
- (void)onNewLocationUpdate:(GULocation * _Nonnull)location;
@end


/// GeoUniq class. Every method can be accessed by the sharedInstance() method. The very first time call the method setMobileKey(mobileKey: String) to authenticate the device and start the tracking.
SWIFT_CLASS("_TtC7GeoUniq7GeoUniq")
@interface GeoUniq : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger MAX_CUSTOM_ID_LENGTH;)
+ (NSInteger)MAX_CUSTOM_ID_LENGTH SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Obtain the version name of GeoUniq framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull FrameworkVersionName;)
+ (NSString * _Nonnull)FrameworkVersionName SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq. You will also notify about the device-id
/// \param callbackDeviceId function callback where you will be notify about the device-id
///
///
/// returns:
/// GeoUniq singleton
+ (GeoUniq * _Nonnull)sharedInstance:(void (^ _Nonnull)(NSString * _Nonnull))callbackDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Obtain the shared instance of GeoUniq
///
/// returns:
/// GeoUniq singleton
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Return the mobileKeykey in the info.plist file or nil if none
///
/// returns:
/// the mobileKey provided
- (NSString * _Nullable)getMobileKey SWIFT_WARN_UNUSED_RESULT;
/// Return the id relative to the device if it has been registered, nil otherwise.
/// You should handle the device id in the callback of the sharedInstance() method
///
/// returns:
/// the device id if available or nil otherwise
- (NSString * _Nullable)getDeviceId SWIFT_WARN_UNUSED_RESULT;
/// Enable the tracking of the device.
/// If the tracking is running this method has no influence on the system.
- (void)enable;
/// Disable the tracking of the device (until the application is not killed)
/// It will restart when explicitly call start() method or sharedInstance(…) if the key GUAutoStartedTracking is set to true
- (void)disable;
/// Return the starting granularity if the basic tracking is set to true, nil otherwise
/// If the basic tracking is set to true but no accuracy has been provided, will be returned the default granularity (10000)
///
/// returns:
/// the starting granularity in meters
- (double)getStartingTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking
/// \param granularity set the starting granularity in meters
///
- (void)setStartingTrackingGranularity:(double)granularity;
/// Reset the value to the one provided in the Info.plist file
- (void)resetStartingTrackingGranularity;
/// Return the granularity of the current tracking session(until the app is killed)
///
/// returns:
/// granularity for the current tracking session
- (double)getCurrentTrackingGranularity SWIFT_WARN_UNUSED_RESULT;
/// Set the granularity for the basic tracking of this session (until the app is killed), then will be used the starting accuracy provided if the service is open
/// \param granularity the granularity in meters for the current tracking session
///
- (void)setCurrentTrackingGranularity:(double)granularity;
/// Ask GeoUniq for a location with the given accuracy.
/// \param accuracy accuracy requested for the position
///
/// \param callback class delegate to receive the location
///
- (void)getPosition:(double)accuracy callback:(id <GUPositionReceiver> _Nonnull)callback;
/// Allow the print of the log for warnings and errors
/// \param enable true if you want to print out the logs
///
- (void)enableDebug:(BOOL)enable;
/// Return true if the tracking is active
///
/// returns:
/// boolean
- (BOOL)isTrackingActive SWIFT_WARN_UNUSED_RESULT;
/// Call on the background fetch event of the device
- (void)backgroundFetch;
/// Register the application for the background fetch with the minimum interval (UIApplicationBackgroundFetchIntervalMinimum)
- (void)registerBackgroundFetch;
/// Register the device to receive remote notifications, if the iOS version is older than 8.0.0 register the device for Badge, Alert and Sounds. You Will receive the device token in the application:didRegisterForRemoteNotificationsWithDeviceToken method, or in application:didReceiveRemoteNotification in case of errors; remember to forward the deviceToken to GeoUniq service with the method ‘registerDeviceToken(deviceToken: NSData)’
- (void)registerRemoteNotifications;
/// Forward the device token received by the application:didRegisterForRemoteNotificationsWithDeviceToken method
/// \param deviceToken token provided by iOS
///
- (void)registerDeviceToken:(NSData * _Nonnull)deviceToken;
/// Set the label for the tracking session. The value will label all future positions on the server until you explicitelly change it or reset it.
/// The max String length is 10000 characters.
/// \param label label you want to assing to the tracking session
///
///
/// returns:
/// true if the string could used for the label
- (BOOL)setLabelSession:(NSString * _Nullable)label SWIFT_WARN_UNUSED_RESULT;
/// Get the label for the tracking session
///
/// returns:
/// the label for the tracking session
- (NSString * _Nullable)getLabelSession SWIFT_WARN_UNUSED_RESULT;
/// Reset the label to the default value (nil)
- (void)resetLabel;
/// Request motion activity permission for use the hardaware chip
- (void)requestMotionActivityPermission;
/// Get motion activity permission status (aviable only from iOS 11)
///
/// returns:
/// the current authorization status
- (CMAuthorizationStatus)getMotionActivityPermission SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=11.0);
/// Return the current motion activity (the last detected)
///
/// returns:
/// the current activity
- (GUMotionActivity * _Nullable)getCurrentActivity SWIFT_WARN_UNUSED_RESULT;
/// Get privacy consent status
- (BOOL)getConsentStatus SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "getPrivacyConsents");
/// set privacy consent status
- (void)setConsentStatusWithIsGranted:(BOOL)isGranted SWIFT_DEPRECATED_MSG("", "setPrivacyConsent");
/// show pop-up for privacy consent ask and set status
/// -returns: completion isGranted (Bool)
- (void)showConsentDialogAndSetWithCompletion:(void (^ _Nonnull)(BOOL))completion SWIFT_DEPRECATED_MSG("", "showPrivacyPolicyAndSetWithCompletion:");
- (void)showPrivacyPolicyAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)showPrivacyPolicySwitchesAndSetWithCompletion:(void (^ _Nonnull)(ConsentsMap * _Nonnull))completion;
- (void)setPrivacyConsent:(enum ConsentItem)consent value:(BOOL)value;
- (BOOL)getPrivacyConsent:(enum ConsentItem)consent SWIFT_WARN_UNUSED_RESULT;
- (ConsentsMap * _Nonnull)getPrivacyConsentsMap SWIFT_WARN_UNUSED_RESULT;
/// Obtain the last location registered
- (GULocation * _Nullable)getLastKnownLocation SWIFT_WARN_UNUSED_RESULT;
/// Obtain the location history of the device given a timeframe and a type of sort
/// \param from start time frame
///
/// \param to end of the time frame
///
/// \param sort type of sort for the locations
///
/// \param locationsReceiver callback on which the locations will be delivered
///
- (void)getLocationHistory:(NSDate * _Nonnull)from to:(NSDate * _Nonnull)to sort:(enum GUSort)sort locationsReceiver:(id <GULocationHistoryReceiver> _Nonnull)locationsReceiver;
/// Allows to register this Device to all the Groups whose name is equal to the parameter
/// \param name indicating the name of the Group(s) of interest
///
- (void)registerToGroupsWithName:(NSString * _Nonnull)name;
/// Allows to register this Device to the Group whose ID is equal to the parameter
/// \param groupId indicating the ID of the Group of interest
///
- (void)registerToGroupWithId:(NSString * _Nonnull)groupId;
/// Store the Cusom Endpoint Object to use for the Location forwarding.
/// In order to create the <code>CustomEndpoint</code> object use <code>CustomEndpoint.Builder</code>, it will allow you to build correctly the <code>CustomEndpoint</code>.
/// After this method remember to call <code>.enableCustomEndpoint()</code> in order to enable the forward of locations
/// \param endpoint representation of the parameters of the call
///
- (void)setCustomEndpointWithEndpoint:(CustomEndpoint * _Nonnull)endpoint;
/// Return the <code>CustomEndpoint</code> in use
///
/// returns:
/// custom endpoint
- (CustomEndpoint * _Nullable)getCustomEndpoint SWIFT_WARN_UNUSED_RESULT;
/// Remove the ´CustomEnpoint´ in use, this command will disable the forwards of locations
- (void)removeCustomEndpoint;
/// Enable the forward of locations using the parameters in the <code>CustomEnpoint</code> stored
- (void)enableCustomEndpoint;
/// Disable the forward of locations, the <code>CustomEndpoint</code> is still stored for a later use
- (void)disableCustomEndpoint;
/// Return the current state of the forwarding locations to a custom endpoint: enabled or disabled
///
/// returns:
/// boolean
- (BOOL)isCustomEndpointEnabled SWIFT_WARN_UNUSED_RESULT;
/// Check if the tracking is possible on this device, the parameters checked are:
/// <ul>
///   <li>
///     location permission granted or not determined
///   </li>
///   <li>
///     parameters in Info.plist file correctly provided
///   </li>
/// </ul>
/// In addition will be logged (if enabled) the status of permission
///
/// returns:
/// the possibility to track the device
- (BOOL)isLocationTrackingAvailable SWIFT_WARN_UNUSED_RESULT;
/// Register a delegate to receive all the locations update, even in background
/// \param listener listener to register
///
- (void)setTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener;
/// Remove a registered delegate for locations update
/// \param listener registered listener
///
///
/// returns:
/// true if a argument listener exists. False otherwise.
- (BOOL)removeTrackingListenerWithListener:(Class <GUTrackingListener> _Nonnull)listener SWIFT_WARN_UNUSED_RESULT;
/// Allows to obtain the set listeners
///
/// returns:
/// <code>[GUTrackingListener.Type]</code>
- (NSArray<Class <GUTrackingListener>> * _Nullable)getTrackingListeners SWIFT_WARN_UNUSED_RESULT;
/// Removes all listener previously set
- (void)removeAllTrackingListeners;
- (BOOL)setCustomId:(NSString * _Nonnull)customId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCustomId SWIFT_WARN_UNUSED_RESULT;
/// Sets  a <code>GUGeofence</code> for the geographical area indicated by area argument
/// and the callback class indicated by the listener argument
/// \param area A <code>GUCircularArea</code> representing the circular area to be monitored
///
/// \param listener A class adopting the <code>GUGeofenceListener</code> protocol
///
/// \param expirationDate Expiration date of the <code>GUGeofence</code>, after this date the <code>GUGeofence</code> will be deleted
///
///
/// returns:
/// the created <code>GUGeofence</code> object
- (GUGeofence * _Nonnull)setGUGeofenceWithArea:(GUCircularArea * _Nonnull)area listener:(Class <GUGeofenceListener> _Nonnull)listener expirationDate:(NSDate * _Nullable)expirationDate SWIFT_WARN_UNUSED_RESULT;
/// Removes the <code>GUGeofence</code> with id equal to the <code>id</code> argument, if any.
/// \param id the id of the <code>GUGeofence</code> to be removed
///
///
/// returns:
/// true if a <code>GUGeofence</code> with the provided id exists. False otherwise.
- (BOOL)removeGUGeofenceWithId:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// Removes all <code>GUGeofence</code> previously set
- (void)removeAllGUGeofence;
/// Allows to obtain the set <code>GUGeofence</code> objects
///
/// returns:
/// <code>[GUGeofence]</code>
- (NSArray<GUGeofence *> * _Nonnull)getGUGeofences SWIFT_WARN_UNUSED_RESULT;
- (NSArray<GUGeofence *> * _Nonnull)getRemoteGUGeofences SWIFT_WARN_UNUSED_RESULT;
@end


/// Responsible for handling all delegate callbacks for the underlying session.
SWIFT_CLASS("_TtC7GeoUniq15SessionDelegate")
@interface SessionDelegate : NSObject
/// Initializes the <code>SessionDelegate</code> instance.
///
/// returns:
/// The new <code>SessionDelegate</code> instance.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Returns a <code>Bool</code> indicating whether the <code>SessionDelegate</code> implements or inherits a method that can respond
/// to a specified message.
/// \param selector A selector that identifies a message.
///
///
/// returns:
/// <code>true</code> if the receiver implements or inherits a method that can respond to selector, otherwise <code>false</code>.
- (BOOL)respondsToSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
@end

@class NSURLSession;
@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDownloadDelegate>
/// Tells the delegate that a download task has finished downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that finished.
///
/// \param location A file URL for the temporary file. Because the file is temporary, you must either
/// open the file for reading or move it to a permanent location in your app’s sandbox
/// container directory before returning from this delegate method.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
/// Periodically informs the delegate about the download’s progress.
/// \param session The session containing the download task.
///
/// \param downloadTask The download task.
///
/// \param bytesWritten The number of bytes transferred since the last time this delegate
/// method was called.
///
/// \param totalBytesWritten The total number of bytes transferred so far.
///
/// \param totalBytesExpectedToWrite The expected length of the file, as provided by the Content-Length
/// header. If this header was not provided, the value is
/// <code>NSURLSessionTransferSizeUnknown</code>.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
/// Tells the delegate that the download task has resumed downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that resumed. See explanation in the discussion.
///
/// \param fileOffset If the file’s cache policy or last modified date prevents reuse of the
/// existing content, then this value is zero. Otherwise, this value is an
/// integer representing the number of bytes on disk that do not need to be
/// retrieved again.
///
/// \param expectedTotalBytes The expected length of the file, as provided by the Content-Length header.
/// If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
@end

@class NSURLAuthenticationChallenge;
@class NSURLCredential;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDelegate>
/// Tells the delegate that the session has been invalidated.
/// \param session The session object that was invalidated.
///
/// \param error The error that caused invalidation, or nil if the invalidation was explicit.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
/// Requests credentials from the delegate in response to a session-level authentication request from the
/// remote server.
/// \param session The session containing the task that requested authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate that all messages enqueued for a session have been delivered.
/// \param session The session that no longer has any outstanding requests.
///
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * _Nonnull)session;
@end

@class NSURLSessionDataTask;
@class NSURLResponse;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionDataDelegate>
/// Tells the delegate that the data task received the initial reply (headers) from the server.
/// \param session The session containing the data task that received an initial reply.
///
/// \param dataTask The data task that received an initial reply.
///
/// \param response A URL response object populated with headers.
///
/// \param completionHandler A completion handler that your code calls to continue the transfer, passing a
/// constant to indicate whether the transfer should continue as a data task or
/// should become a download task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveResponse:(NSURLResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(NSURLSessionResponseDisposition))completionHandler;
/// Tells the delegate that the data task was changed to a download task.
/// \param session The session containing the task that was replaced by a download task.
///
/// \param dataTask The data task that was replaced by a download task.
///
/// \param downloadTask The new download task that replaced the data task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask;
/// Tells the delegate that the data task has received some of the expected data.
/// \param session The session containing the data task that provided data.
///
/// \param dataTask The data task that provided data.
///
/// \param data A data object containing the transferred data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
/// Asks the delegate whether the data (or upload) task should store the response in the cache.
/// \param session The session containing the data (or upload) task.
///
/// \param dataTask The data (or upload) task.
///
/// \param proposedResponse The default caching behavior. This behavior is determined based on the current
/// caching policy and the values of certain received headers, such as the Pragma
/// and Cache-Control headers.
///
/// \param completionHandler A block that your handler must call, providing either the original proposed
/// response, a modified version of that response, or NULL to prevent caching the
/// response. If your delegate implements this method, it must call this completion
/// handler; otherwise, your app leaks memory.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionStreamTask;
@class NSInputStream;
@class NSOutputStream;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionStreamDelegate>
/// Tells the delegate that the read side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session readClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the write side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session writeClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the system has determined that a better route to the host is available.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session betterRouteDiscoveredForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
/// \param session The session.
///
/// \param streamTask The stream task.
///
/// \param inputStream The new input stream.
///
/// \param outputStream The new output stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session streamTask:(NSURLSessionStreamTask * _Nonnull)streamTask didBecomeInputStream:(NSInputStream * _Nonnull)inputStream outputStream:(NSOutputStream * _Nonnull)outputStream;
@end

@class NSURLSessionTask;
@class NSHTTPURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(GeoUniq)) <NSURLSessionTaskDelegate>
/// Tells the delegate that the remote server requested an HTTP redirect.
/// \param session The session containing the task whose request resulted in a redirect.
///
/// \param task The task whose request resulted in a redirect.
///
/// \param response An object containing the server’s response to the original request.
///
/// \param request A URL request object filled out with the new location.
///
/// \param completionHandler A closure that your handler should call with either the value of the request
/// parameter, a modified URL request object, or NULL to refuse the redirect and
/// return the body of the redirect response.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
/// Requests credentials from the delegate in response to an authentication request from the remote server.
/// \param session The session containing the task whose request requires authentication.
///
/// \param task The task whose request requires authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate when a task requires a new request body stream to send to the remote server.
/// \param session The session containing the task that needs a new body stream.
///
/// \param task The task that needs a new body stream.
///
/// \param completionHandler A completion handler that your delegate method should call with the new body stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
/// Periodically informs the delegate of the progress of sending body content to the server.
/// \param session The session containing the data task.
///
/// \param task The data task.
///
/// \param bytesSent The number of bytes sent since the last time this delegate method was called.
///
/// \param totalBytesSent The total number of bytes sent so far.
///
/// \param totalBytesExpectedToSend The expected length of the body data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
/// Tells the delegate that the task finished transferring data.
/// \param session The session containing the task whose request finished transferring data.
///
/// \param task The task whose request finished transferring data.
///
/// \param error If an error occurred, an error object indicating how the transfer failed, otherwise nil.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
@end


/// The task delegate is responsible for handling all delegate callbacks for the underlying task as well as
/// executing all operations attached to the serial operation queue upon task completion.
SWIFT_CLASS("_TtC7GeoUniq12TaskDelegate")
@interface TaskDelegate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end











#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif
#endif
